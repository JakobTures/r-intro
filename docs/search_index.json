[["index.html", "Kurzeinführung zu R Einleitung Inhalt Konventionen Danksagung Colophon", " Kurzeinführung zu R Jakob Tures 2022-04-01 Einleitung Diese Kurzeinführung zu R und in die Datenanaylse mit dem tidyverse package wurde als Begleitmaterial für das Lehrforschungsprojekt “Supervised Machine Learning: Zwischenrufe im Bundestag” an der Universität Potsdam im Sommersemester 2022 erstellt. Inhalt Kapitel 1 &amp; 2 führen in die Grundlagen von R und RStudio ein. R ist eine Programmiersprache die vor allem für statistische Analysen Anwendung findet. Die Grundfunktionen von R können durch das Einbinden von professionellen und nutzergeschriebenen packages erweitert werden. Diese Erweiterungen sind es, die R so flexibel machen und neben statistischen Analysen unter anderem auch das Schreiben von Websites direkt in R – so wie diese Website – und die Aufbereitung und Analyse von Textdaten ermöglichen. RStudio ist ein IDE – integrated development environment – für R und vereinfacht das Arbeiten mit der Sprache. Die ersten beiden Kapitel umfassen Informationen zur Installation beider Softwares, der Bedienung von RStudio sowie grundlegender R Befehlen. Während Kapitel 2 bereits die grundlegenden Prinzipien des tidyverse – einer populären Sammlung von R packages – erläutert, befassen sich Kapitel 3 &amp; 4 mit den zwei Bestandteilen der Sammlung die wir in der Datenanalyse am häufigsten verwenden werden. dplyr wird genutzt um Daten zu bereinigen, zu transformieren, neue Daten aus bestehenden zu erzeugen und zusammenfassende Statistiken zu berechnen. gplot2 gibt uns einen umfassenden Werzeugkasten zur graphischen Analyse an die Hand. Wir betrachten dessen grundlegende Syntax, einige häufig genutzte Diagrammtypen sowie Optionen die erstellten Plots ansprechend und aussagekräftig zu gestalten. Konventionen Die R Welt ist eine englischssprachige Welt. Die Namen von packages und Funktionen sind meist mehr oder weniger sprechend und stets Englisch. Auch sind die meisten Begriffe die sich auf R und RStudio beziehen englischsprachig. Sinnvolle Übersetzungen existieren meist nicht. Auch wäre es nicht zielführend diese Begriffe selbst zu übersetzen da dies nur unnötig verwirren würde. Einer der wichtigsten Skills die Sie im Umgang mit einer Sprache wie R entwickeln müssen, ist das gezielte Suchen nach Problemen beziehungsweisen deren Lösungen in Büchern und vor allem auch im Internet. Dazu benötigen Sie das englischsprachige Fachvokabular. Aus diesem Grund wurden englischsprachigen Fachbegriffe eingebunden ohne sie zu übersetzen. Die Namen von R packages werden fett geschrieben. Da R case sensitive ist, also Groß- und Kleinschreibung nicht beliebig austauschbar ist, werden die Namen der packages exakt so geschrieben wie sie benannt sind, auch wenn sie am Satzbeginn stehen. Ein Beispiel ist: tidytext Alle Codebeispiele sind in code font gesetzt. Teilweise im Text: print(\"Hello World\"), teilweise als code block: print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; Der output des R codes wird direkt innerhalb des code blocks hinter ## gedruckt. Ich empfehle dringend den Inhalt der code blocks selbst in RStudio laufen zu lassen und den code dabei auch selbst zu tippen statt ihn zu kopieren. Um eine Sprache wir R zu erlernen, muss man sie regelmäßig selbst schreiben. Nur so können die Namen häufig genutzter Funktionen sowie die R syntax in Ihr “muscle memory” übergehen. Danksagung Besonderer Dank gilt Lukas Höttges für die Unterstützung bei der Erstellung dieser Website. Gleichermaßen danke ich den aktuellen und ehemaligen Teammitgliedern des Lehrstuhls für Methoden der empirischen Sozialforschung an der Universität Potsdam für ihr wertvolles Feedback zu technischen und inhaltlichen Fragen in diversen Kaffeepausen und Zoom-Gesprächen. Dank gilt auch den Erstellern der genutzten R packages, insbesondere bookdown und tidyverse, sowie der gesamten R community. Colophon sessioninfo::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.1.2 (2021-11-01) ## os Ubuntu 20.04.4 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Europe/Berlin ## date 2022-03-26 ## pandoc 2.11.4 @ /usr/lib/rstudio/bin/pandoc/ (via rmarkdown) ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date (UTC) lib source ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.1.1) ## backports 1.4.0 2021-11-23 [1] CRAN (R 4.1.2) ## bookdown * 0.24 2021-09-02 [1] CRAN (R 4.1.2) ## broom 0.7.10 2021-10-31 [1] CRAN (R 4.1.2) ## bslib 0.3.1 2021-10-06 [1] CRAN (R 4.1.2) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.1.1) ## cli 3.1.0 2021-10-27 [1] CRAN (R 4.1.2) ## codetools 0.2-18 2020-11-04 [4] CRAN (R 4.0.3) ## colorspace 2.0-2 2021-06-24 [1] CRAN (R 4.1.1) ## crayon 1.4.2 2021-10-29 [1] CRAN (R 4.1.2) ## DBI 1.1.1 2021-01-15 [1] CRAN (R 4.1.1) ## dbplyr 2.1.1 2021-04-06 [1] CRAN (R 4.1.1) ## digest 0.6.29 2021-12-01 [1] CRAN (R 4.1.2) ## dplyr * 1.0.7 2021-06-18 [1] CRAN (R 4.1.1) ## ellipsis 0.3.2 2021-04-29 [1] CRAN (R 4.1.1) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.1.1) ## fansi 0.5.0 2021-05-25 [1] CRAN (R 4.1.1) ## fastmap 1.1.0 2021-01-25 [1] CRAN (R 4.1.1) ## forcats * 0.5.1 2021-01-27 [1] CRAN (R 4.1.1) ## fs 1.5.2 2021-12-08 [1] CRAN (R 4.1.2) ## generics 0.1.1 2021-10-25 [1] CRAN (R 4.1.2) ## ggplot2 * 3.3.5 2021-06-25 [1] CRAN (R 4.1.1) ## glue 1.6.0 2021-12-17 [1] CRAN (R 4.1.2) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.1.1) ## haven 2.4.3 2021-08-04 [1] CRAN (R 4.1.1) ## hms 1.1.1 2021-09-26 [1] CRAN (R 4.1.2) ## htmltools 0.5.2 2021-08-25 [1] CRAN (R 4.1.1) ## httr 1.4.2 2020-07-20 [1] CRAN (R 4.1.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.1.1) ## jsonlite 1.7.2 2020-12-09 [1] CRAN (R 4.1.1) ## knitr * 1.36 2021-09-29 [1] CRAN (R 4.1.2) ## lifecycle 1.0.1 2021-09-24 [1] CRAN (R 4.1.2) ## lubridate 1.8.0 2021-10-07 [1] CRAN (R 4.1.2) ## magrittr 2.0.1 2020-11-17 [1] CRAN (R 4.1.1) ## modelr 0.1.8 2020-05-19 [1] CRAN (R 4.1.1) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.1.1) ## pillar 1.6.4 2021-10-18 [1] CRAN (R 4.1.2) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.1.1) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.1.1) ## R6 2.5.1 2021-08-19 [1] CRAN (R 4.1.1) ## Rcpp 1.0.7 2021-07-07 [1] CRAN (R 4.1.1) ## readr * 2.1.1 2021-11-30 [1] CRAN (R 4.1.2) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.1.1) ## reprex 2.0.1 2021-08-05 [1] CRAN (R 4.1.1) ## rlang 0.4.12 2021-10-18 [1] CRAN (R 4.1.2) ## rmarkdown 2.13 2022-03-10 [1] CRAN (R 4.1.2) ## rstudioapi 0.13 2020-11-12 [1] CRAN (R 4.1.1) ## rvest 1.0.2 2021-10-16 [1] CRAN (R 4.1.2) ## sass 0.4.0 2021-05-12 [1] CRAN (R 4.1.1) ## scales 1.1.1 2020-05-11 [1] CRAN (R 4.1.1) ## sessioninfo 1.2.2 2021-12-06 [1] CRAN (R 4.1.2) ## stringi 1.7.6 2021-11-29 [1] CRAN (R 4.1.2) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.1.1) ## tibble * 3.1.6 2021-11-07 [1] CRAN (R 4.1.2) ## tidyr * 1.1.4 2021-09-27 [1] CRAN (R 4.1.2) ## tidyselect 1.1.1 2021-04-30 [1] CRAN (R 4.1.1) ## tidyverse * 1.3.1 2021-04-15 [1] CRAN (R 4.1.1) ## tzdb 0.2.0 2021-10-27 [1] CRAN (R 4.1.2) ## utf8 1.2.2 2021-07-24 [1] CRAN (R 4.1.1) ## vctrs 0.3.8 2021-04-29 [1] CRAN (R 4.1.1) ## withr 2.4.3 2021-11-30 [1] CRAN (R 4.1.2) ## xfun 0.30 2022-03-02 [1] CRAN (R 4.1.2) ## xml2 1.3.3 2021-11-30 [1] CRAN (R 4.1.2) ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.1.1) ## ## [1] /home/jakobtures/R/x86_64-pc-linux-gnu-library/4.1 ## [2] /usr/local/lib/R/site-library ## [3] /usr/lib/R/site-library ## [4] /usr/lib/R/library ## ## ────────────────────────────────────────────────────────────────────────────── "],["R1.html", "1 R Basics 1.1 Installation 1.2 Erste Schritte 1.3 Objekte 1.4 Vektoren 1.5 Weitere Datentypen 1.6 R Packages 1.7 Funktionen 1.8 Hilfe?", " 1 R Basics 1.1 Installation In diesem Kurs werden wir mit der Sprache R in Kombination mit der Entwicklungsumgebung RStudio arbeiten. Bevor wir mit der Einführung in die grundlegende Bedienung beginnen, zunächst einige Worte zur Installation der kostenlos zugänglichen Software. 1.1.1 R R ist eine Programmiersprache, die vor allem für statistische Analysen angewandt wird. Generelle Informationen zu R und die ausführliche Dokumentation finden sie unter: https://www.r-project.org/. Die aktuellste Version von R für alle gängigen Betriebssysteme findet sich stets im CRAN, dem Comprehensive R Archive Network unter: https://cran.r-project.org/. Die Links zu den Installationsdateien finden sich im oberen Bereich der Website. Falls Sie Windows nutzen, wählen Sie bitte die “base” Version. Im Falle von MacOS, hängt die Wahl des Installers von der Version Ihres Betriebssystems ab. In beiden Fällen führen Sie bitte die passende Datei aus und Installieren Sie R in ein Verzeichnis Ihrer Wahl. Für Linux Systeme stellt CRAN Installationsanweisungen für einige der populären Distribution bereit. Die Code Beispiele auf dieser Website wurden mit der R Version 4.1.1 “Kick Things” erstellt und getestet. 1.1.2 RStudio R kann nun bereits ausgeführt werden, erlaubt aber nur die Nutzung einer einfachen Konsole. Um die Arbeit mit R angenehmer zu gestalten, empfiehlt sich dringend die zusätzliche Installation einer IDE – Integrated Development Environment – also einer graphischen Benutzeroberfläche. Die populärste IDE ist RStudio, zu finden unter: https://www.rstudio.com/. Unter “Download” wählen Sie bitte die kostenlose Version von “RStudio Desktop” und den passenden Installer für Ihr Betriebssystem. Installieren Sie bitte zuerst R und erst danach RStudio. Starten brauchen Sie dann in Zukunft nur noch RStudio. 1.2 Erste Schritte 1.2.1 Übersicht RStudio Das RStudio Interface besteht aus vier Unterbereichen. Links-unten finden Sie die “Console” sowie weitere Tabs, die Sie zu Beginn selten bis nie brauchen werden. Die Konsole kann genutzt werden, um R code einzugeben und auszuführen, mehr dazu in Kürze. Links-oben werden geöffnete R scripts angezeigt. Aktuell haben Sie noch kein script geöffnet, ab Kapitel 2 wird dort aber der überwiegende Teil unserer Arbeit stattfinden. Rechts-oben finden sich mehrere Tabs, von denen für uns vor allem das “Environment” Tab von Interesse ist. Hier werden alle Objekte gelistet die Sie in ihrem code erstellen. Auch hierzu in Kürze mehr. Rechts-unten finden Sie erneute eine Anzahl Tabs. “Files” zeigt uns die Dateistruktur unseres Rechners, “Plots” den graphischen output (siehe Kapitel 3) und “Help” die Hilfedateien zu Funktionen und packages (mehr in Kapitel 2). 1.2.2 Hello World! Nun können wir endlich damit beginnen unseren ersten R Befehl auszuführen. In diesem Kapitel werden wir Kommandos noch ausschließlich in der Konsole schreiben. In der untersten Zeile der Konsole sehen Sie ein &gt; Symbol. Hinter dieser Eingabeaufforderung können wir unsere Befehle schreiben und mit “Enter” ausführen. Versuchen Sie des mit folgender Zeile: print(&quot;Hello World!&quot;) ## [1] &quot;Hello World!&quot; Sie haben gerade ihren ersten R Befehl ausgeführt, Ihren ersten Output erhalten und gleichzeitig auch Ihre erste Funktion genutzt. Mehr zu Funktionen folgt am Ende dieses Kapitels, fürs Erste genügt es aber zu wissen, dass print() alles innerhalb der Klammern als Output druckt. Der Output selbst beginnt mit [1], was anzeigt, dass dies das erste und hier das einzige Element des Outputs ist. Bitte beachten Sie, dass R die auf dieser Website vor dem Output dargestellten ## nicht abdruckt. 1.2.3 Rechnen mit R R versteht die arithmethischen Operatoren + - * /. Sie können R also auch als übergroßen Taschenrechner nutzen. Für fortgeschrittenere Rechenoperationen steht eine Vielzahl von Funktionen zur Verfügung. Beispielsweise gibt Ihnen sqrt() die Quadratwurzel der von den Klammern umfassten Zahl als Output zurück. Oben mussten wir den Text \"Hello World!\" in Anführungszeichen einfassen. Zahlen müssen hingegen ohne Anführungszeichen geschrieben werden. Potenzen bekommen wir mit der Notation x^y. Im folgenden Codeblock finden Sie einige Beispiele, die Sie Zeile für Zeile in die console tippen und mit “Enter” ausführen können: 17 + 25 ## [1] 42 99 - 57 ## [1] 42 4 * 10.5 ## [1] 42 84 / 2 ## [1] 42 sqrt(1764) ## [1] 42 6.480741 ^ 2 ## [1] 42 1.2.4 Vergleichsoperatoren Vergleichsoperatoren können genutzt werden um zwei Werte miteinander zu vergleichen und das Testergebnis als TRUE oder FALSE Output zu erhalten. Um zu überprüfen, ob zwei Werte gleich sind, schreiben wir ==. Dabei ist zu beachten, dass ein Vergleich zweier Werte stets zwei Gleichheitszeichen voraussetzt. = hat eine andere Bedeutung! Um zu testen ob zwei Werte nicht gleich sind, können wir != nutzen, wobei das ! generell für nicht steht. 42 == 42 ## [1] TRUE 42 != 42 ## [1] FALSE Weitere mögliche Vergleiche sind kleiner &lt;, kleiner gleich &lt;=, größer &gt; und größer gleich &gt;=. 10 &lt; 42 ## [1] TRUE 42 &lt;= 42 ## [1] TRUE 10 &gt; 42 ## [1] FALSE 90 &gt;= 42 ## [1] TRUE 1.3 Objekte In R können wir Daten und Ergebnisse unserer Analysen in Objekten speichern. So bleiben diese im Arbeitsspeicher erhalten und können später erneut aufgerufen und weiterverwendet werden. Ein Objekt ist dabei ein frei gewählter Name dem wir Daten zuweisen. Namen müssen dabei mit einem Buchstaben beginnen und sollten nur weitere Buchstaben, Ziffern oder _ beinhalten. Verbreitete Konventionen für längere Objektnamen sind snake case – the_answer – und camel case – theAnswer. Dies ist letztlich Geschmackssache, es empfielt sich aber eine einheitliche Schreibweise sowie kurze aber klar verständliche Namen zu verwenden. Daten weisen wir einem Objekt mit dem assignment operator &lt;- zu. the_answer &lt;- 42 Um sich Fingerakrobatik zu ersparen, ist es sinnvoll sich frühzeitig die Tastenkombination “Alt” + “-” anzugewöhnen, die &lt;- an der aktuellen Cursor Position einfügt. Die so in einem Objekt gespeicherten Daten können wir aufrufen, indem wir den Objektnamen als Befehl schreiben. the_answer ## [1] 42 Wir können Werte in Objekten auch direkt in Berechnungen oder in Funktionen verwenden. Beachten Sie dabei, dass die Daten eines Objekts überschrieben werden, wenn wir diesem neue Daten zuweisen. the_answer &lt;- the_answer / 2 the_answer ## [1] 21 a &lt;- 17 b &lt;- 4 the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 So erstellte Objekte werden in dem “Environment” Tab (rechts-oben) gelistet. Möchten wir erstellte Objekte entfernen, können wir dazu die rm() Funktion nutzen. Dies ist zwar in der Regel nicht notwendig, kann aber hilfreich sein um versehentlich oder nur zum Test erstellte Objekte zu löschen und so den Tab etwas aufzuräumen. rm(the_answer) 1.4 Vektoren Als wir weiter oben eine Zahl einem Objekt zugewiesen haben, haben wir ohne es zu wissen bereits unseren ersten Vektor erstellt. Vektoren sind eindimensionale Datenstrukturen, die mehrere Elemente enthalten können. Die Länge eines Vektors bestimmt sich dabei anhand der Anzahl seiner Elemente. So erstellt auch the_answer &lt;- 42 einen Vektor, jedoch einen Vektor der Länge 1. Möchten wir einen Vektor mit mehreren Elementen erstellen, nutzen wir dazu die Funktion c(), wobei “c” für “combine” steht. So werden alle durch Kommata getrennten Werte innerhalb der Klammern zu einem Vektor kombiniert. v &lt;- c(7, 8, 9, 10) v ## [1] 7 8 9 10 1.4.1 Subsetting Möchten wir bestimme Elemente eines Vektors abrufen, nutzen wir subsetting. Dazu schreiben wir die Position des gewünschten Elements innerhalb des Vektors als Zahl in [] direkt nach dem Objektnamen. Um beispielsweise das erste oder das dritte Element unseres Vektors abzurufen: v[1] ## [1] 7 v[3] ## [1] 9 Mehrere Elemente gleichzeitig rufen wir ab indem wir mehrere Positionen mit c() kombinieren oder wir definieren mit : eine Spannweite von Positionen. v[c(1, 3)] ## [1] 7 9 v[2:4] ## [1] 8 9 10 1.4.2 Typen von Vektoren Betrachten wir den Vektor v im Environment, fällt auf, dass RStudio num [1:4] vor den gespeicherten Werten abduckt. Dies drückt zum einen aus, dass der Vektor die Länge 4 hat, zum anderen zeigt es den Typ des Vektors an. Hier handelt es sich um einen numerischen Vektor – numeric, ausgedrückt durch “num” – also einen Vektor der Zahlen enthält. Um Imformationen zu Typ, Länge und Inhalt von Objekten zu erhalten können wir auch die Funktion str() – structure – nutzen. Dies ist vor allem bei komplexeren Objekten wie Listen oder Dataframes (mehr dazu später) hilfreich, um einen ersten Überblick zu erhalten, ohne das komplette Objekt abzudrucken. str(v) ## num [1:4] 7 8 9 10 R kennt noch weitere Typen von Vektoren, wobei für uns vor allem die Typen logical und character von Bedeutung sind. Logische Vektoren können nur die Werte TRUE und FALSE enthalten. Diese entstehen beispielsweise, wenn wir Vergleichsoperatoren für einen Test nutzen. x &lt;- c(1, 7, 3, 5) x &gt;= 5 ## [1] FALSE TRUE FALSE TRUE Wir können logische Vektoren aber auch selbst erstellen. z &lt;- c(TRUE, FALSE, TRUE) z ## [1] TRUE FALSE TRUE Character Vektoren beinhalten Zeichenfolgen, sogenannte strings. Strings müssen stets von Anführungszeichen umschlossen sein. char_v &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;character&quot;, &quot;vector!&quot;) char_v ## [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;character&quot; &quot;vector!&quot; Auch Character Vektoren können miteinander verglichen werden. &quot;same&quot; == &quot;same&quot; ## [1] TRUE &quot;same&quot; == &quot;not the same&quot; ## [1] FALSE &quot;same&quot; != &quot;not the same&quot; ## [1] TRUE Da wir mit Character Vektoren natürlich nicht rechnen können, kann es zu Problemen kommen, wenn wir Zahlenwerte – beispielsweise als Strings aus einem Text ausgelesen – als Character Vektor gespeichert haben. a &lt;- c(1, 2, 3) b &lt;- c(&quot;7&quot;, &quot;8&quot;, &quot;9&quot;) str(a) ## num [1:3] 1 2 3 str(b) ## chr [1:3] &quot;7&quot; &quot;8&quot; &quot;9&quot; a + b ## Error in a + b: non-numeric argument to binary operator Wir können R aber anweisen einen Character Vektor in einen numerischen Vektor umzuwandeln. a + as.numeric(b) ## [1] 8 10 12 Alle Typen von Vektoren können neben ihren nativen Inhalten auch NA enthalten, die Repräsentation von fehlenden Werten in R. c &lt;- c(1, 2, NA, 4) c ## [1] 1 2 NA 4 1.5 Weitere Datentypen 1.5.1 Dataframes Dataframes sind zweidimensionale Datenobjekte aus Spalten und Zeilen, also das was wir uns im Allgemeinen unter einer Tabelle vorstellen. Spalten enthalten benannte Variablen, Zeilen enthalten Beobachtungen. Um einen Dataframe zu erstellen nutzen wir die Funktion data.frame() und definieren innerhalb der Klammern benannte Spalten und ihre Inhalte, getrennt durch Kommata. df &lt;- data.frame(Name = c(&quot;Peter&quot;, &quot;Mary&quot;), Alter = c(42, 24), Weiblich = c(FALSE, TRUE)) df ## Name Alter Weiblich ## 1 Peter 42 FALSE ## 2 Mary 24 TRUE R erkennt dabei automatisch, welche Datentypen die Spalten enthalten. str(df) ## &#39;data.frame&#39;: 2 obs. of 3 variables: ## $ Name : chr &quot;Peter&quot; &quot;Mary&quot; ## $ Alter : num 42 24 ## $ Weiblich: logi FALSE TRUE Wir können Dataframes auch aus zuvor definierte Vektoren zusammensetzen. name &lt;- c(&quot;Peter&quot;, &quot;Mary&quot;) age &lt;- c(42, 24) female &lt;- c(FALSE, TRUE) df_2 &lt;- data.frame(Name = name, Alter = age, Weiblich = female) df_2 ## Name Alter Weiblich ## 1 Peter 42 FALSE ## 2 Mary 24 TRUE Da Dataframes zweidimensional sind, müssen wir beim Subsetting auch eine Position für die Zeilen und Spalten angeben. Diese werden ebenfalls in [] nach dem Objektnamen eingefasst und sind durch ein Komma getrennt. Vor dem Komma steht die Position der Zeilen, nach dem Komma die Position der Spalten. Für Spalten können wir statt der Position auch den Namen der Spalte nutzen. df[1, 2] ## [1] 42 df[1, &quot;Alter&quot;] ## [1] 42 Extrahieren wir mehrere Zeilenelemente gleichzeitig, bekommen wir einen neuen Dataframe zurück. Um eine ganze Zeile zu extrahieren, können wir den Wert der Spaltenposition auch freilassen. Gleiches gilt für ganze Spalten, wobei wir beim Subsetting einer einzelnen Spalte einen Vektor als Output bekommen, bei mehreren erneut einen Dataframe. df[1, 2:3] ## Alter Weiblich ## 1 42 FALSE df[1, ] ## Name Alter Weiblich ## 1 Peter 42 FALSE df[, &quot;Alter&quot;] ## [1] 42 24 df[, c(&quot;Alter&quot;, &quot;Weiblich&quot;)] ## Alter Weiblich ## 1 42 FALSE ## 2 24 TRUE 1.5.2 Listen Vektoren und Spalten von Dataframes können immer nur Daten eines Typs enthalten. Mischen wir Datentypen, werden diese auf den kleinsten gemeinsamen Nenner gebracht. Logische Werte können auch numerisch abgebildet werden, da TRUE dem Wert 1 entspricht, FALSE dem Wert 0. In letzter Instanz können alle Datentypen als Character Vektoren gespeichert werden. log_vector &lt;- c(24, TRUE) str(log_vector) ## num [1:2] 24 1 char_vector &lt;- c(&quot;Mary&quot;, 24, TRUE) str(char_vector) ## chr [1:3] &quot;Mary&quot; &quot;24&quot; &quot;TRUE&quot; Möchten wir Datentypen mischen, können wir stattdessen Listen nutzen, welche unterschiedliche Datentypen enthalten können. l &lt;-list(&quot;Mary&quot;, 24, TRUE) str(l) ## List of 3 ## $ : chr &quot;Mary&quot; ## $ : num 24 ## $ : logi TRUE Um Listen wieder aufzulösen, nutzen wir unlist(). unlist(l) ## [1] &quot;Mary&quot; &quot;24&quot; &quot;TRUE&quot; Listen können sogar andere Listen enthalten und sind so das flexibelste Datenobjekt das R bereitstellt. Beim Subsetting von Listen ist darauf zu achten, dass [] immer auch eine Liste zurückgibt, selbst wenn diese nur noch ein Element enthält. Direkten Zugang zu Elementen erhalten wir mit [[]]. str(l[1]) ## List of 1 ## $ : chr &quot;Mary&quot; str(l[[1]]) ## chr &quot;Mary&quot; 1.6 R Packages Die R Welt ist offen und kollaborativ. Neben dem base R Package, das in der Grundinstallation bereits enthalten ist, steht eine stetig steigende Zahl von nutzergeschriebenen Packages zum Download zur Verfügung. Diese Packages haben stets einen thematischen Fokus – beispielsweise Datenbereinigung, graphische Analyse oder Textanalyse – und enthalten eine Reihe von Funktionen, die den Einsatzbereich von R über das hinaus erweitern, was von den Originalentwicklern geplant war, oder kompliziert gestaltete base R Ansätze durch neue anwenderfreundlichere Funktionen ersetzen. Packages, ihre Dokumentation und weitere Informationen werden ebenfalls auf CRAN gehostet. Hier haben Sie auch bereits die Installationsdateien für R heruntergeladen. Wenn Sie gleich ein Package direkt aus RStudio installieren, greift die Software auf CRAN zu, um die erforderlichen Dateien herunterzuladen. 1.6.1 Installieren und Laden Packages installieren wir mit der R Funktion install.packages(), mit dem Namen des packages in \"\" zwischen den Klammern der Funktion. Wir werden im Laufe des Seminars eine Reihe von Packages nutzen, darunter das tidyverse. Zur Installation des core tidyverse packages schreiben wir in der Konsole: install.packages(&quot;tidyverse&quot;) R wird während der Installation eine lange Reihe von Informationen ausgeben, von denen uns – solange alles gut geht – nur das DONE (tidyverse) interessieren muss. Nach erfolgreicher Installation können wir das Paket laden. Ein Package laden wir mit library() mit dem Namen des Packages innerhalb der Klammern, hier ausnahmsweise ohne \"\". library(tidyverse) Manche Pakete, wie das tidyverse, geben uns auch beim Laden eine Reihe von Informationen, die wir gleich noch genauer betrachten werden. Andere Pakete laden aber auch still, ohne Informationen in die Konsole zu schreiben. Sollte beim Laden eines packages ein Problem auftauchen, wird R dies rückmelden. 1.7 Funktionen Bis zu diesem Punkt haben wir bereits eine Reihe von Funktionen genutzt, ohne eigentlich zu wissen, was Funktionen sind. Die in base R und den diversen Packages enthaltenen Funktionen bieten einen einfachen Zugang zu komplexeren im Hintergrund ablaufenden Operationen. Statt beispielsweise eine komplizierte Datenanalysetechnik selbst zu implementieren, also jeden Rechenschritt Zeile für Zeile selbst zu schreiben, installieren wir ein Package mit einer passenden Funktion und sparen eventuell mehrere hundert Zeilen Code ein. Außerdem sind die Rechenoperationen in den Packages meist sehr viel effizienter geschrieben als Code, den wir als Laien schreiben würden. Um eine Funktion aufzurufen, schreiben wir deren Namen gefolgt von Klammern. Innerhalb der Klammern geben wir ein oder mehrere Argumente an die Funktion weiter. In vielen Fällen wird als erstes oder eniziges Argument ein Datenobjekt – oder rohe Daten – angegeben, auf das die Funktion angewandt werden soll. So “druckt” beispielsweise die base R Funktion print() die angegebenen Daten in die Konsole, wie bereits bei print(\"Hello World!\") gesehen. Weitere Beispiele für Funktionen sind einige der in base R enthaltenen Möglichkeiten, statistische Maßzahlen zu berechnen. Legen wir zunächst einen numerischen Vektor mit einigen Beispieldaten an: data &lt;- c(4, 8, 15, 16, 23, 42) Unser Interesse sei es, das arithmetische Mittel, den Median sowie die Standardabweichung der Daten zu berechnen. Dazu können wir die Funktionen mean(), median() und sd() aus base R nutzen. Allen drei Funktionen geben wir als einziges Argument die zuvor in einem Objekt gespeicherten Daten weiter. Weitere Argumente sind zwar möglich, für dieses Beispiel aber nicht notwendig. mean(data) ## [1] 18 median(data) ## [1] 15.5 sd(data) ## [1] 13.49074 Funktionen erlauben häufig mehrere Argumente, von denen einige optional sein können und es beispielsweise ermöglichen bestimmte Optionen einer Funktion zu verändern. Dies wird uns im weiteren Verlauf regelmäßig begegenen. 1.7.1 Namesspaces Betrachten wir nochmals den Output nach dem Laden von tidyverse weiter oben. R gibt uns neben Namen und Versionen der geladenen packages – das core tidyverse Package, welches wir geladen haben ist eigentlich eine Sammlung von Packages – auch die Information über zwei Konflikte aus. Konflikte entstehen, wenn zwei geladene packages Funktionen mit den selben Namen enthalten. Die Funktion aus dem später geladenen package überschreibt dabei die zuvor geladene Funktion. Hier überschreibt das tidyverse package dplyr die Funktionen filter() und lag() aus dem base R package stats. Ohne dplyr beziehungsweise tidyverse zu laden wäre beim aufruf von filter() die Funktion aus dem stats package genutzt worden. Nun wird die gleichnamige Funktion aus dplyr angewandt. Möchten wir zwar dplyr laden, aber die Funktion filter() aus stats nutzen, können wir den Namespace der Funktion explizit angeben. Der Namespace gibt R an, in welchem Package es nach der Funktion suchen soll. Geben wir nur den Funktionsnamen an, sucht R in den Funktionen die aktuell geladen sind. Da filter() aus dplyr die Funktion aus stats überschrieben hat, würde erstere angewandt. Deklarieren wir den Namespace, können wir R genau angeben, in welchem geladenen oder ungeladenen package die Funktion zu finden ist. Dazu nutzen wir die Notation namespace::function. Um also filter() aus stats zu nutzen, schreiben wir: stats::filter(). 1.8 Hilfe? 1.8.1 Hilfe! Wir haben nun bereits einige R Funktionen kennengelernt und eine ungefähre Idee davon, was diese machen. Wie bekommen wir aber weitere Informationen zu diesen und neuen Funktionen, zu deren Funktionsweise, den zugelassenen Argumenten oder den zurückgegebenen Ergebnissen? Der einfachste Weg ist das Nutzen der eingebauten Hilfefunktionalitäten in R. Dazu schreiben wir in der Konsole einfach ein ? vor den Namen einer Funktion, zu der wir Hilfe benötigen. Die zugehörige Hilfedatei öffnet sich dann im “Help” Tab, rechts-unten. Versuchen wir dies für die Funktion rnorm(). ?rnorm() Die Hilfedatei gibt uns eine ganze Reihe von Informationen. rnorm() ist Teil einer Familie von Funktionen, die sich auf die Normalverteilung beziehen. Dabei ist es die Funktionalität von rnorm(), Zufallszahlen aus der Normalverteilung zu generieren. Wir sehen auch, dass wir der Funktion 3 Argumente geben können. Die Anzahl der zu erzeugenden Zufallszahlen n sowie Mittelwert mean und Standardabweichung sd der zugrundeliegenden Normalverteilung. Dabei ist zu erkennen, dass mean und sd die Standardwerte 0 beziehungsweise 1 haben. Diese werden automatisch eingesetzt, wenn wir sie im Funktionsaufruf nicht durch neue Werte ersetzen. n hat keinen Standardwert, hier müssen wir also einen Wert angeben wenn wir die Funktion aufrufen. rnorm(n = 10) ## [1] -0.3058367 0.7187122 -0.4376060 -0.4125264 -0.6004963 0.4240317 ## [7] 1.3075067 0.2435375 -0.1935374 -0.1808801 So bekommen wir 10 Zufallswerte aus der Normalverteilung mit dem Mittelwert 0 und der Standardabweichung 1. Da es sich um Zufallszahlen handelt, wird Ihr Output von dem auf der Website dargestellten abweichen. Möchten wir Mittelwert und Standardabweichung anpassen, können wir die entsprechenden Argumente nutzen um die Standardwerte durch andere zu ersetzen. rnorm(n = 10, mean = 10, sd = 0.5) ## [1] 10.782300 9.324677 10.421483 9.335728 11.104446 9.472333 10.257398 ## [8] 10.001974 9.754984 9.268117 Die Hilfe gibt uns meist auch weitere detaillierte Informationen zur Funktionsweise und dem Output (unter\" Value\") der Funktion, sowie eine Reihe von Beispielsanwendungen. Diese Informationen richten sich oft aber an eher erfahrene Nutzer. Weiter Möglichkeiten sich zur Funktionsweise von Packages sowie R generell zu informieren, finden Sie in Kapitel 2. "],["R2.html", "2 RStudio &amp; das tidyverse 2.1 RStudio workflow 2.2 tidyverse 2.3 Weitere Hilfe!", " 2 RStudio &amp; das tidyverse 2.1 RStudio workflow Im vorangegangenen Kapitel haben wir unsere Befehle direkt in die R Konsole eingegeben, mit “Enter” bestätigt und unseren Output zurückbekommen. Dies ist allerdings nicht die standardmäßige Anwendung von R (oder anderen Programmiersprachen). Das Hauptproblem besteht hierbei darin, dass unser Code nach dem Ausführen nicht erhalten bleibt. Wir können zwar durch die Konsole scrollen, um nachzuvollziehen, welche Befehle wir genutzt haben, dies ist uns aber spätestens nach dem Schließen von RStudio nicht mehr zugänglich. In der Realität werden Sie aber häufig längere Zeiträume an einem Projekt arbeiten und möchten eventuell ihren Code mit Kommiliton:innen, Kolleg:innen oder der R Community teilen. Je komplexer unser Code wird, desto mehr Fehler werden wir auch machen. Ein früher Fehler in der Konsole, der erst spät auffällt, kann bedeuten, dass der Großteil unserer Arbeit wiederholt werden müsste. Deswegen arbeitet man statt der Konsole mit sogenannten Scripts. 2.1.1 R Scripts Ein R Script ist eine Datei, in der wir unsere Befehle niederschreiben und so für die spätere Weiterarbeit und Weitergabe dokumentieren. Um ein neues R Script zu erstellen, klicken Sie auf “File” &gt; “New File” &gt; “R Script”, oder nutzen Sie die praktische Tastenkombination “CTRL” + “Shift” + “N”. So wird ein leeres und unbenanntes neues Script erstellt. Als erste Übung können wir ein Stück Code aus dem vorangegangenen Kapitel statt in die Konsole in unser R Script eingeben. a &lt;- 17 b &lt;- 4 the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 Zur Erinnerung: wir erstellen zwei numerische Objekte a und b, weisen das Ergebnis einer Berechnung mit diesen zwei Objekten einem neuem Objekt the_answer zu und lassen uns dieses Objekt, also das Ergebnis der Berechnung, ausgeben. Statt die Befehle Zeile für Zeile in die Konsole einzugeben und jede Zeile direkt auszuführen, schreiben wir zunächst den kompletten Codeblock in unser neues Script. Danach können wir unser komplettes Script durch einen Klick auf “Source” in der toolbar des Script Fensters ausführen. Ich empfehle Ihnen stattdessen aber, Scripts stets Befehl für Befehl auszuführen. So haben Sie die volle Kontrolle über den Prozess, sehen sofort das Ergebnis (oder den Fehler) jedes einzelnen Befehls und können die Ausführung an jeder beliebigen Stelle pausieren, zum Beispiel um den Code besser nachzuvollziehen, Fehler zu erkennen oder Veränderungen vorzunehmen. Umsetzen können Sie dies mit einem Klick auf “Run” in der Toolbar des Scripttabs oder noch einfacher durch das Drücken von “CTRL” + “Enter”. In beiden Fällen wird die Zeile, in der sich aktuell Ihr Cursor befindet ausgeführt. Dieser springt daraufhin automatisch in die nächste Zeile, sodass Sie auch Befehl für Befehl schnell ihr ganzes Script ausführen können, dabei aber die volle Kontrolle behalten. Was für Sie praktikabler ist, müssen Sie selbst entscheiden und kann auch von der Situation abhängen. Bedenken Sie aber immer, dass R zu jedem Zeitpunkt davon ausgeht, dass Sie wissen was Sie tun. Es wird keine Warnmeldungen geben, wenn Sie etwas überschreiben das Sie eigentlich nicht überschreiben wollten. Sie sollten ihr Script regelmäßig abspeichern. Nicht nur dann, wenn Sie eine Arbeitssession beenden, sondern regelmäßig. Dies können sie über “File” &gt; “Save” erreichen oder durch die Tastenkombination “CTRL” + “S”. Sie können den Namen des Scripts frei wählen, die Endung muss jedoch immer “.R” sein. Ein Problem, das Ihnen früher oder später begegnen wird, ist, dass Sie versehentlich versuchen werden inkompletten Code aus einem Script auszuführen. Der Grund ist sehr häufig eine fehlende schließende Klammer, wie in print(\"Hello World\". R kann den Code nicht interpretieren und geht aufgrund der fehlenden Klammer davon aus, dass der Code noch weitergehen soll. R übernimmt dann den inkompletten Code in die Konsole, führt ihn aber nicht aus, sondern beginnt eine neue Zeile mit einem +. Dies bedeutet, dass wir hinter dem + den Code fortsetzen können. In der Regel ist es dann am sinnvollsten, die Ausführung des Codes abzubrechen, indem sie in die Konsole klicken und danach “Esc” drücken. Dann können wir den Code in unserem Script korrigieren und erenut ausführen. 2.1.2 Projekte Häufig werden unsere R Vorhaben aus mehreren Dateien – wie Scripts, Datensätzen oder ausgegebenen Graphiken – bestehen. Es macht dann häufig Sinn, diese Dateien an einem gemeinsamen Ort abzuspeichern. Dies könnten wir natürlich “per Hand” managen, RStudio’s Projektfunktion kann hier aber sehr hilfreich sein. Durch Klicken auf “File” &gt; “New Project”, erstellen wir ein neues Projekt. Haben wir bereits einen Ordner für das Projekt angelegt, können wir auf “Existing Directory” klicken, den Ordner auswählen und die Erstellung mit “Create Project” abschließen. Oder wir erstellen mit “New Directory” &gt; “New Project” einen neuen Ordner für das Projekt direkt aus RStudio. RStudio wird nun alle aktuell geöffneten Dateien schließen und in das neu erstellte Projekt wechseln. Der Name des gewählten oder erstellten Ordners ist auch gleichzeitig der Name des Projekts, angezeigt in der Titelleiste von RStudio. Der “Files” tab (rechts-unten) zeigt nun auch den Inhalt des Projektordners. Dies ist ihr aktuelles working directory, mehr dazu gleich. Sie können nun Dateien erstellen und bearbeiten und speichern diese ganz normal ab. Das Projekt selbst muss nie gespeichert werden. Möchten Sie in einer späteren R Session ihre Arbeit an dem Projekt fortsetzen, klicken Sie auf “File” &gt; “Open Project”. Das Projekt wird geöffnet, alle Dateien die Sie bei der letzten Session geöffnet hatten sind erneut geöffnet und Sie befinden sich auch wieder im working directory des Projekts. Projekte sind eine einfache und praktische Methode, um Ihre Arbeiten zu organisieren und aufgeräumt zu halten. An dieser Stelle wäre es eventuell sinnnvoll, wenn Sie ein Projekt zu diesem Seminar erstellen. Sie könnten dann Scripts für jedes Kapitel anlegen oder weitere Unterordner für Übungen usw. einrichten. Ob dies für Sie eine sinnvolle Arbeitsweise ist, bleibt aber Ihnen überlassen. Wir sollten nun noch kurz über das working directory sprechen. Dieses wird zum Beispiel dann relevant, wenn Sie versuchen eine Datei direkt aus einem Script heraus zu öffnen oder zu speichern. Geben Sie dabei keinen kompletten absoluten Pfad an, geht R immer davon aus, dass Sie sich auf das working directory beziehen. Arbeiten Sie in einem Projekt, ist das working directory automatisch das Hauptverzeichnis des Projekts. Mit getwd() gibt Ihnen R ihr aktuelles Arbeitsverzeichnis zurück. Ihr Arbeitsverzeichnis können Sie über “Session” &gt; “Set Working Directory” &gt; “Choose Directory…” oder mit der Funktion setwd() ändern, wobei der Pfad mit \"\" eingefasst zwischen die Klammern geschrieben wird. 2.1.3 Kommentare Einer der wichtigsten Skills beim Schreiben von Code, ist das Kommentieren des Selbigen. Kommentare können wir direkt in Scripts schreiben, diese werden jedoch nicht ausgeführt, sondern dienen der Erläuterung und Strukturierung des Codes. Einen Kommentar markieren wir mit einem oder mehreren #. Text der auf ein # folgt wird von R als Kommentar erkannt und entsprechend nicht ausgeführt. Wenn Sie über längere Zeit an einem Projekt arbeiten oder dieses nach längerer Zeit erneut öffnen, kann es für sie selbst manchmal schwierig sein nachzuvollziehen, was Sie mit ihrem Code erreichen wollten. Gut kommentierter Code erleichtert dies stark. Dies wird nochmals relevanter, wenn Sie ihren Code mit anderen Personen teilen. Für die meisten Probleme in R bestehen eine Vielzahl möglicher Ansätze. Gut kommentierter Code hilft Anderen zu verstehen, was ihr Ansatz ist. Hier können Sie die Zeit, die Sie in das Kommentieren investieren als Respekt gegenüber der Zeit verstehen, die Andere investieren um Ihren Code zu verstehen. Ihnen wird eventuell aufgefallen sein, dass der Output der Codeblöcke auf dieser website mit ## beginnt. Im Output Ihrer R Konsole fehlen diese. Beim Erstellen der Website mit dem package bookdown werden die Symbole automatisch im Output eingefügt, um das Kopieren und Einfügen der Code Blöcke in Ihre Scripts zu erleichtern. So wird der mit ## markierte Output von R als Kommentar verstanden und nicht als Befehl ausgeführt. Dies ist oft praktisch, trotzdem empfehle ich weiterhin, so viel wie möglich selbst zu Tippen und copy/paste nur spärlich zu verwenden. Hier ein Beispiel eines bereits bekannten Codeblocks, diesmal mit Kommentaren versehen: # assigning objects a &lt;- 17 b &lt;- 4 # calculating the answer the_answer &lt;- (a + b) * 2 the_answer ## [1] 42 # but what is the question? Falls Sie setwd() in Ihrem Script verwenden, empfiehlt es sich, dies auszukommentieren, bevor sie das Script weitergeben. Andere Personen haben andere Ordnerstrukturen als Sie und können mit Ihrem individuellen setwd() nichts anfangen. Im besten Fall wird ihr setwd() nicht ausführbar sein, im schlechtesten bringen Sie die Ordnerstruktur einer anderen Person durcheinander. Ähnliches gilt für Befehle, die etwas auf die Festplatte speichern, beispielsweise Datensätze oder exportierte Graphiken. Die R community ist grundsätzlich sehr bereitwillig auch Anfängern mit Coding Problemen zu helfen. Wir sollten diese Bereitschaft damit würdigen gut kommentierten Code weiterzugeben und davon abzusehen, in die Dateistruktur anderer Personen einzugreifen. 2.1.4 Speichern Aus dem Blickwinkel reproduzierbarer Datenanalyse ist es aus meiner Sicht meist der beste Ansatz, ein Script zu erstellen in dem die rohen Daten eingelesen, bereinigt, transformiert sowie statistisch und graphisch analysiert werden. So ist es jeder Person mit Zugriff auf die Daten und ihr Script möglich, jeden ihrer Arbeitsschritte nachzuvollziehen und zu reproduzieren. Dies ist eine der Säulen transparenter wissenschaftlicher Praxis. Bei diesem Ansatz müssen wir also selten die Ergebnisse unserer Analysen als Datensatz abspeichern. Das Script – die “.R” Datei – ist ausreichend. Es gibt aber auch Situationen, in denen es sinnvoll sein kann, Ergebnisse abzuspeichern. Quantitative Textanalysen können bespielsweise sehr rechenintensiv sein. Bei der Anwendung fortgeschrittener Methoden im Machine Learning auf sehr große Datensätze, können schonmal mehrere Stunden bis Tage Rechenzeit anfallen. Auch wenn wir solche Zeitdmensionen in diesem Seminar nicht erreichen, kann es hilfreich sein auch die Ergebnisse einer Operation im niedrigen Minutenbereich abzuspeichern, um Rechenzeit bei regelmäßiger Arbeit mit den Ergebnissen zu sparen. Die einfachste Möglichkeit ist es, zum Speichern das native R Datenformat “.RData” zu nutzen. Erstellen wir einen kurzen Dataframe, um diesen gleich abzuspeichern: data &lt;- data.frame( name = c(&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;), age = c(42, 84, 24), size = c(1.68, 1.82, 1.74), retired = c(FALSE, TRUE, FALSE) ) Mit save() können wir “.RData” Dateien speichern. Dazu schreiben wir innerhalb der Klammern zunächst den Namen des Objekts – oder mehrerer Objekte mit c() zusammengefasst – gefolgt von einem , und dem Argument file = \"\". Innerhalb der \"\" legen wir einen Dateinamen mit einem optionalen Pfad fest. Eine Datei ohne angegebenen Pfad wird im aktuellen working directory gespeichert. save(data, file = &quot;peter_paul_mary.RData&quot;) Um die gespeicherten Daten wieder zu laden, nutzen wir die Funktion load() mit dem Namen beziehungsweise Pfad der Datei als einzigem Argument. load(&quot;peter_paul_mary.RData&quot;) So haben wir Daten in dem schnellen und gut komprimierten nativen “.RData” Format gespeichert. Der Nachteil ist, dass diese Daten auch nur in R genutzt werden können. Interessieren sie sich dafür, Daten in einem besser transportierbaren Format zu speichern, bietet sich “.csv” an. Mehr dazu in Kapitel 3.5 sowie hier: https://jakobtures.github.io/web-scraping/files.html 2.2 tidyverse Weiter oben haben wir das tidyverse Package installiert und geladen. Dieses wird uns durch das ganze Seminar begleiten. Das tiydverse ist eine beliebte Sammlung von R Packages, die einer gemeinsamen Philosophie der Funktionssyntax sowie der Datenstruktur folgen und dabei viele datenanalytische Arbeitsprozesse abdecken. Der Vorteil ist, dass Sie, sobald Sie die Grundlogik verstanden haben, sehr schnell auch weitere tidyverse Packages verstehen werden. Letztlich ist es Geschmackssache, aber aus meiner Sicht führt das Arbeiten mit dem tidyverse zu intuitiverem und flüßiger zu schreibendem R Code. Aktuell besteht das core tidyverse Package aus acht individuellen Packages. Diese werden alle automatisch geladen, wenn wir library(tidyverse) schreiben. Das core tidyverse deckt einen Großteil der besonders regelmäßig auftretenden datenanalytischen Funktionalitäten ab. Dazu gehören das Einlesen, Reinigen und Transformieren von Daten oder die graphische Analyse. Im weiteren werden wir viele Funktionen aus dem core tidyverse sehr regelmäßig nutzen. Nebem dem core tidyverse besteht eine wachsende Zahl zugehöriger Packages, welche nach den selben Grundsätzen funktionieren, dabei aber speziellere Aufgabenfelder abdecken. Auch diese wurden mit install.Packages(\"tidyverse\") bereits installiert, müssen aber explizit geladen werden. Darunter beispielsweise lubridate zum Umgang mit Datumsangaben und eine Reihe von Packages zum Einlesen bestimmter Datentypen. Eine volle Liste der tidyverse Packages finden Sie unter: https://www.tidyverse.org/Packages/ Für eine umfassendere Einführung in das tidyverse bietet sich das Buch “R for Data Science” von Wickham &amp; Grolemund an, welches auch Online zugänglich ist: https://r4ds.had.co.nz/ 2.2.1 tidy data Das tidyverse folgt einer geteilten Philosophie der Datenstruktur namens tidy data. Einfach ausgedrückt steht tidy data dafür, dass jede Variable eines Datensatz eine eigene Spalte in einer Tabelle bekommt und jede Beobachtung eine eigene Zeile. Die Werte zu den Kombinationen von Variablen und Beobachtungen stehen dann logisch folgend in den Zellen. Betrachten wir folgenden Dataframe, welcher bisherige (04.09.2021) Umfragewerte für die Wahl zum 20. Bundestag enthält. Die Daten stammen von: https://www.wahlrecht.de/umfragen/index.htm ## Institut CDU_CSU SPD GRÜNE FDP LINKE AfD Sonstige ## 1 Kantar 21 25 19 11 7 11 6 ## 2 Infratest 20 25 16 13 6 12 8 Diese Darstellungsform ist uns sofort intuitiv verständlich. So sehen Tabellen in Excel oder in Zeitungen aus und die Darstellung ist kompakt und übersichtlich. Aber ist Sie auch tidy? Dazu müssen wir uns Gedanken darüber machen, welche Variablen die Tabelle enthält. Die erste Spalte bildet die Variable “Institut” ab. Dies macht Sinn. Die restlichen 7 Spalten enthalten die Umfragewerte für die 6 aktuell im Bundestag vertretenen Parteien sowie “Sonstige”. Wir haben also eigentlich 2 Variablen: “Umfragewert” und “Partei”, welche aktuell in 7 Spalten dargestellt werden. Sie erinnern sich, jede Variable bekommt in einem tidy Datensatz eine Spalte. Zudem werden die Werte der Variable “Partei” auch gar nicht als Werte in der Tabelle sondern in den Spaltennamen abgebildet. Die Tabelle ist also eindeutig nicht tidy. Vergleichen Sie dies zu folgendem Dataframe: ## Institut Partei Umfragewert ## 1 Kantar CDU_CSU 21 ## 2 Kantar SPD 25 ## 3 Kantar GRÜNE 19 ## 4 Kantar FDP 11 ## 5 Kantar LINKE 7 ## 6 Kantar AfD 11 ## 7 Kantar Sonstige 6 ## 8 Infratest CDU_CSU 20 ## 9 Infratest SPD 25 ## 10 Infratest GRÜNE 16 ## 11 Infratest FDP 13 ## 12 Infratest LINKE 6 ## 13 Infratest AfD 12 ## 14 Infratest Sonstige 8 Diese Darstellung ist tidy. Wir haben 3 Variablen “Institut”, “Partei” und “Umfragewert” die jeweils in einer eigenen Spalte stehen. Beobachtungen sind nun nicht mehr das komplette Set von Umfragewerten eines Umfrageinstituts, sondern der Umfragewert einer Partei bei einem Insitut. Das Ergebnis ist eine Tabelle, die den Prinzipien der tidy data folgt, die uns auf den ersten Blick aber seltsam erscheint, da wir nicht daran gewohnt sind, Daten in dieser Form darzustellen. Wir sollten aber auch bedenken, dass es an dieser Stelle nicht das Ziel ist, eine schöne Tabelle für menschliche Leser zu präsentieren, sondern ein Datenobjekt zu konstruieren, welches uns die praktische und komfortabele Weiterarbeit mit den diversen tidyverse Packages ermöglicht. Mehr zu den angedeuteten Prinzipien der tidy data finden Sie im entsprechenden Kapitel von “R for Data Science” von Wickham &amp; Grolemund: https://r4ds.had.co.nz/tidy-data.html. 2.2.2 Tibbles Das tibble Package ist Teil des core tidyverse und bietet eine Alternative zur base R Darstellung von Tabellen als Dataframes. Dabei liegen viele der Unterschiede zwischen Tibbles und Dataframes eher im Detail. Für uns sind vor allem die Art wie Tibbles in die Konsole gedruckt werden und wie das subsetting funktioniert relevant. Mehr zu Beidem gleich. Eine ausführlichere Einführung finden Sie erneut in “R for Data Science”: https://r4ds.had.co.nz/tibbles.html Tibbles erstellen wir dabei auf die selbe Weise wie Dataframes, nutzen dazu aber die Funktion tibble(). Dazu müssen wir zunächst das tibble beziehungsweise das tidyverse Package, welches tibble enthält, laden. Das Laden von Packages sollte in den ersten Zeilen eines Scripts passieren. So werden alle notwendigen Packages zu Beginn eines Scripts geladen und andere Nutzer*innen sehen sofort welche Packages eventuell noch nachinstalliert werden müssen. Hier geben wir die Daten direkt bei der Erstellung der Tibble ein. Wie bei Dataframes können wir Tibbles aber auch aus zuvor definierten Vektoren zusammensetzen. library(tidyverse) tibble(numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE)) ## # A tibble: 3 × 3 ## numbers strings logicals ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 0 zero FALSE ## 2 1 one TRUE ## 3 2 two TRUE Bevor wir den Output betrachten, ein genereller Hinweis: Je länger unser Code wird, desto unübersichtlicher wird er auch. Wir sollten längeren Code deshalb über mehrere Zeilen aufteilen und durch Einrücken kennzeichnen, welche Codesegmente zusammengehörig sind. Das Einrücken übernimmt RStudio weitestgehend automatisch, wir können aber auch selbst Tabs hinzufügen oder entfernen um Zeilen einzurücken. Eine übersichtlicher formatierte, inhaltlich aber identische Version des vorangegangenen Codes könnte wie folgt aussehen: tibble( numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE) ) ## # A tibble: 3 × 3 ## numbers strings logicals ## &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 0 zero FALSE ## 2 1 one TRUE ## 3 2 two TRUE R interpretiert dies identisch zur Schreibweise in einer Zeile und weiß, dass alles zwischen der öffnenden und schließenden Klammer Teil der aufgerufenen Funktion ist. Lassen sie uns nun den Output betrachten. Dieser ist grundsätzlich ähnlich zu dem Output eines Dataframes, wobei 2 Unterschiede bestehen. Zum Einen wird der Datentyp einer Spalte unter deren Namen abgebildet. Zum Anderen werden längere Tibbles verkürzt abgedruckt, wie wir später noch sehen werden. Dataframes werden hingegen stets vollständig gedruckt, was bei großen Datenmengen nur dazu führt, dass in der Konsole eigentlich nichts mehr lesbar ist. Ein weiterer wichtiger Unterschied besteht im Subsetting von Tibbles. Das Subsetting mit [] gibt uns immer einen neuen tibble zurück, mit [[]] bekommen wir einen Vektor. Sind wir nur an Spalten interessiert, reicht es übrigens nur die Spaltenposition zwischen den Klammern einzutragen. So bekommen wir die komplette Spalte, also über alle Zeilen, zurück. Alternativ zur numerischen Position, können wir auch die Spaltennamen nutzen. Entweder zwischen den eckigen Klammern oder in der $-Notation. tbl_exmpl &lt;- tibble( numbers = c(0, 1, 2), strings = c(&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;), logicals = c(FALSE, TRUE, TRUE) ) str(tbl_exmpl[1]) ## tibble [3 × 1] (S3: tbl_df/tbl/data.frame) ## $ numbers: num [1:3] 0 1 2 str(tbl_exmpl[[1]]) ## num [1:3] 0 1 2 str(tbl_exmpl[[&quot;numbers&quot;]]) ## num [1:3] 0 1 2 str(tbl_exmpl$numbers) ## num [1:3] 0 1 2 Viele tidyverse Funktionen nutzen Tibbles statt Dataframes – so auch die Funktionen des tidytext Packages, welches wir im Verlaufe des Seminars ausgiebig nutzen werden – und Funktionen aus anderen Packages werden meist Dataframes zurückgeben. Wir können beide Datenobjekte aber auch konvertieren. Dazu nutzen wir die base R Funktion as.data.frame() bzw. die dplyr Funktion as_tibble(). str(tbl_exmpl) ## tibble [3 × 3] (S3: tbl_df/tbl/data.frame) ## $ numbers : num [1:3] 0 1 2 ## $ strings : chr [1:3] &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi [1:3] FALSE TRUE TRUE df_exmpl &lt;- as.data.frame(tbl_exmpl) str(df_exmpl) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ numbers : num 0 1 2 ## $ strings : chr &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi FALSE TRUE TRUE tbl_exmpl_2 &lt;- as_tibble(df_exmpl) str(tbl_exmpl_2) ## tibble [3 × 3] (S3: tbl_df/tbl/data.frame) ## $ numbers : num [1:3] 0 1 2 ## $ strings : chr [1:3] &quot;zero&quot; &quot;one&quot; &quot;two&quot; ## $ logicals: logi [1:3] FALSE TRUE TRUE 2.2.3 Die Pipe %&gt;% Ein weiteres Element des tidyverse ist die sogenannte Pipe %&gt;%. Diese ermöglicht das Aneinanderketten von Befehlen, wobei das Ergebnis des vorangegangenen Befehls an den nächsten weitergegeben wird. Dies klingt im Moment noch sehr abstrakt. Betrachten wir also ein praktisches Beispiel. Folgender Code hat das Ziel, für einen Vektor von Zahlen den auf eine Nachkommastelle gerundeten Mittelwert zu berechnen. Dazu müssen wir zunächt den Vektor erstellen und einem Objekt zuweisen, dann den Mittelwert berechnen und erneut einem Objekt zuweisen und in einem letzten Schritt das Runden mit der Funktion round() vornehmen. Das Argument digits = legt dabei die Anzahl der Nachkommastellen fest. data &lt;- c(4.8, 15.16, 23.42) mean_data &lt;- mean(data) round(mean_data, digits = 1) ## [1] 14.5 Dies funktioniert, wir mussten dazu aber auch jeden Zwischenschritt in ein neues Objekt speichern. Nutzen wir stattdessen die Pipe, umgehen wir diese Notwendigkeit und schreiben gleichzeitig kompakteren und intuitiveren Code. data &lt;- c(4.8, 15.16, 23.42) data %&gt;% mean() %&gt;% round(digits = 1) ## [1] 14.5 Die Pipe nimmt das Ergebnis einer Zeile und gibt dieses an die nächste Zeile weiter. Betrachten wir dieses Beispiel Schritt für Schritt: Die erste Pipe gibt das Objekt data an die Funktion mean() weiter. Wie Sie sehen steht dieses mal kein Argument zwischen den Klammern. Trotzdem weiß R, dass mean() auf das Objekt data angewandt werden soll. Dies funktioniert, da die Pipe immer das Ergebnis der vorangegangenen Zeile als erstes Argument der Funktion in der folgenden Zeile einfügt. So wird hier mean() tatsächlich auf das Objekt data angewandt. Das Ergebnis, der Mittelwert, wird durch die nächste Pipe an die letzte Zeile weitergegeben und eneut als erstes Argument eingesetzt, hier in die Funktion round(). Die Rundung wird also auf den in der Zeile zuvor berechneten Mittelwert angewandt. Dies funktioniert reibungslos mit allen Funktionen, die ein Datenobjekt, auf das sie angewandt werden sollen, als erstes Argument nehmen. Dies ist sehr häufig der Fall, aber nicht immer. Der resultierende Code ist intuitiver zu lesen und weniger schreibintensiv, insbesondere wenn Sie sich früh angewöhnen die pipe mit der Tastenkombination “Ctrl” + “Shift” + “M” einzufügen. Das Endergebnis einer Pipe Operation können wir ebenfalls einem Objekt zuweisen. Die Objektzuweisung erfolt dabei allerdings bereits in der ersten Zeile. rounded_mean &lt;- data %&gt;% mean() %&gt;% round(digits = 1) Dies ist auf den ersten Blick etwas unintuitiv, da nicht data dem Objekt rounded_mean zugewiesen wird, sondern das Ergebnis der letzten Zeile, also der gerundetete Mittelwert. 2.3 Weitere Hilfe! 2.3.1 Packages Neben der Hilfefunktion, welche wir bereits in Kapitel 1 kennen gelernt haben, stellen viele Packages sogenannte vignettes bereit: Hilfedateien, die in die Funktionalitäten des Packages einführen. Schauen wir uns dies für das tibble Package an: vignette(package = &quot;tibble&quot;) Wir bekommen so eine Liste mit allen zu tibble verfügbaren vignettes zurück. Einzelne dieser vignettes, rufen wir wie folgt auf: vignette(&quot;types&quot;) Eine ausführlichere Dokumentation zu einem Package, finden Sie außerdem meist auf der dazugehörigen CRAN Seite, hier z.B. für tibble: https://cran.r-project.org/web/Packages/tibble/index.html. 2.3.2 Empfohlene externe Resourcen Es gibt eine Vielzahl von Websites und Büchern zu R und RStudio. Einige davon möchte ich hier vorstellen. Die Website von RStudio umfasst eine große Sammlung von Resourcen zu R und der Arbeit mit spezfischen Packages, darunter auch viele Webinare und Tutorial Videos. Diese finden sie unter dem Menüpunkt “Resources” auf: https://www.rstudio.com/ Die RStudio Cheatsheets zu einigen der beliebteren Packages bieten auf kleinem Raum meist sehr gut zusammengefasste Informationen zu den Funktionen und der Arbeitsweise eines Packages. Die Nutzung der Cheatsheets sei von mir dringend empfohlen, und sie sind nicht nur beim Erlernen eines neuen Packages sondern auch als Erinnerungsstütze extrem hilfreich: https://www.rstudio.com/resources/cheatsheets/ Eine weitere Sammlung von Tutorials zu unterschiedlichsten R Themen finden Sie auf “R-bloggers”: https://www.r-bloggers.com/ Generell finden Sie im Internet eine kaum überschaubare Fülle von Informationen und Resourcen zu R und spezifischen Packages in Form von Videos, Blogs, digitalen Büchern und vor allem auch Foreneinträgen – beispielsweise auf https://stackoverflow.com/. So ist einer der wichtigsten Skills, den Sie entwickeln müssen, das Formulieren von klaren und kurzen Suchanfragen zu Ihrem spezifischen R Problem. In der Regel können Sie davon ausgehen, dass die Antwort bereits im Netz existiert. Ihre Aufgabe ist es nun, ihr Problem gut genug zu verstehen und eine entsprechende Suchanfrage zu schreiben, um auf diese wertvollen Resourcen zugreifen zu können. Das Internet gibt Ihnen ebenfalls Zugang zu einer Vielzahl umfassender Einführungen in R sowie zu Online Versionen von R Büchern: Intro to R for Social Scientists von Jasper Tjaden. Eine an Einsteiger*innen gerichtete Einführung in R, die über das in diesem Seminar gelernte R Basiswissen hinausgeht. Geschrieben als Begleitmaterial zu einem Seminar an der Universität Potsdam im Sommersemester 2021. https://jaspertjaden.github.io/course-intro2r/ R Cookbook, 2nd Edition von J.D. Long &amp; Paul Teetor. Das Kochbuch besteht aus einer Reihe von Rezepten für spezifische Aufgaben, die Sie in R durchführen möchten. Dies ist weniger als durchgängig zu lesendes Buch und mehr als Nachschlagewerk zu nutzen. https://rc2e.com/ R for Data Science von Hadley Wickham &amp; Garrett Grolemund. Eine Einführung in die Datenanalyse mit R, fokussiert auf die Arbeit mit dem tidyverse. Geschrieben von zwei zentralen Figuren des tidyverse und Mitarbeitern bei RStudio. https://r4ds.had.co.nz/ "],["R3.html", "3 Transformation und Analyse mit dplyr 3.1 Die Stammdaten des 17. - 19. Bundestags 3.2 Datentransformation mit dplyr 3.3 Speichern der transformierten Daten 3.4 Deskriptive Datenanalyse mit dplyr 3.5 Export von Tabellen", " 3 Transformation und Analyse mit dplyr 3.1 Die Stammdaten des 17. - 19. Bundestags Dieses und das folgende Kapitel behandeln die Bereinigung, Transformation und deskriptive statistische Analyse von Daten mit dplyr sowie die graphische Analyse mit ggplot2. Zur Veranschaulichung analysieren wir eine Auswahl biographischer Daten der Bundestagsabgeordneten des 19. Bundestags. Die Daten stammen aus einer vom Bundestag bereitgestellten “.xml” Datei und wurden am 24.03.2022 unter folgender URL heruntergeladen: https://www.bundestag.de/services/opendata Das Script zur Extraktion der interessierenden Variablen aus den XML Daten und der Konstruktion des hier genutzten tibbles, finden Sie in meinem GitHub: https://github.com/JakobTures/r-intro/blob/master/scripts/stammdaten_extract.R Das Script speichert eine Tibble mit allen genutzten Daten in der Datei “stammdaten_17_19.RData”, die von Seminarteilnehmer*innen auch in Moodle heruntergeladen werden kann. Laden wir diese Daten zunächst in R. Da es sich bei dem Datenobjekt um eine Tibble handelt, müssen wir auch zunächst das tidyverse package laden. R kennt ohne dieses keine Tibbles und interpretiert das Objekt als Dataframe. library(tidyverse) load(&quot;stammdaten_17_19.RData&quot;) Die Datei enthielt das Objekt stammdaten_17_19, eine Tibble, welche die Stammdaten aller Bundestagsabgeordneten der 17. - 19. Legislaturperiode enthält. Schauen wir uns die Tibble einmal an: stammdaten_17_19 ## # A tibble: 2,060 × 9 ## wp nachname vorname praefix geschlecht alter geb Titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Abercron Michael von männlich 64 17.11.1952 Dr. Union ## 2 19 Achelwilm Doris &lt;NA&gt; weiblich 40 30.11.1976 &lt;NA&gt; DIE LINK… ## 3 17 Ackermann Jens &lt;NA&gt; männlich 34 02.07.1975 &lt;NA&gt; FDP ## 4 19 Aggelidis Grigorios &lt;NA&gt; männlich 52 19.08.1965 &lt;NA&gt; FDP ## 5 17 Ahrendt Christian &lt;NA&gt; männlich 46 07.05.1963 &lt;NA&gt; FDP ## 6 17 Aigner Ilse &lt;NA&gt; weiblich 44 07.12.1964 &lt;NA&gt; Union ## 7 19 Akbulut Gökay &lt;NA&gt; weiblich 34 16.11.1982 &lt;NA&gt; DIE LINK… ## 8 17 Aken Jan van männlich 48 01.05.1961 &lt;NA&gt; DIE LINK… ## 9 18 Aken Jan van männlich 52 01.05.1961 &lt;NA&gt; DIE LINK… ## 10 18 Albani Stephan &lt;NA&gt; männlich 45 03.06.1968 &lt;NA&gt; Union ## # … with 2,050 more rows Die Tibble enthält 2060 Beobachtungen. Zu jeder Beobachtung stehen 9 Variablen bereit. Wahlperiode, Nachname, Vorname, Namenspräfix (bspw. “von”), Geschlecht, Alter, Geburtsdatum, akademischer Titel sowie die Fraktion in welcher der/die MdB die Legislaturperiode begonnen hat. Der Datensatz ist damit so angelegt, dass für eine Abgeordnete eine Beobachtung für jede Wahlperiode vorliegt, in der sie im Bundestag vertreten war. War eine Abgeordnete in allen drei Wahlperioden MdB, liegen entsprechend auch drei separate Beobachtungen vor. Dies entspricht den Prinzipien der tidy data. Wie Sie sehen, werden bei Tibbles standardmäßig nur die ersten 10 Zeilen gedruckt. Die Darstellung ist dadurch kompakt und übersichtlich. Eventuell könnten wir aber daran interessiert sein mehr als 10 Zeilen zu sehen. Ein Weg ist das Anklicken des Objekts im “Environment” Tab oder das Schreiben von View(objektname) in der console. Nun öffnet sich das Objekt in einem neuen Tab und kann komplett betrachtet werden. Ein anderer Weg ist es, R zu zwingen mehr Zeilen in die console abzudrucken. Dies ist mit der Funktion print() möglich. Als zweites Argument können wir mit n = angeben, wie viele Zeilen wir sehen möchten. print(stammdaten_17_19, n = 20) ## # A tibble: 2,060 × 9 ## wp nachname vorname praefix geschlecht alter geb Titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Abercron Michael von männlich 64 17.11… Dr. Union ## 2 19 Achelwilm Doris &lt;NA&gt; weiblich 40 30.11… &lt;NA&gt; DIE LIN… ## 3 17 Ackermann Jens &lt;NA&gt; männlich 34 02.07… &lt;NA&gt; FDP ## 4 19 Aggelidis Grigorios &lt;NA&gt; männlich 52 19.08… &lt;NA&gt; FDP ## 5 17 Ahrendt Christian &lt;NA&gt; männlich 46 07.05… &lt;NA&gt; FDP ## 6 17 Aigner Ilse &lt;NA&gt; weiblich 44 07.12… &lt;NA&gt; Union ## 7 19 Akbulut Gökay &lt;NA&gt; weiblich 34 16.11… &lt;NA&gt; DIE LIN… ## 8 17 Aken Jan van männlich 48 01.05… &lt;NA&gt; DIE LIN… ## 9 18 Aken Jan van männlich 52 01.05… &lt;NA&gt; DIE LIN… ## 10 18 Albani Stephan &lt;NA&gt; männlich 45 03.06… &lt;NA&gt; Union ## 11 19 Albani Stephan &lt;NA&gt; männlich 49 03.06… &lt;NA&gt; Union ## 12 18 Albsteiger Katrin &lt;NA&gt; weiblich 29 20.11… &lt;NA&gt; Union ## 13 17 Alpers Agnes &lt;NA&gt; weiblich 48 29.06… &lt;NA&gt; DIE LIN… ## 14 18 Alpers Agnes &lt;NA&gt; weiblich 52 29.06… &lt;NA&gt; DIE LIN… ## 15 19 Alt Renata &lt;NA&gt; weiblich 52 27.08… &lt;NA&gt; FDP ## 16 19 Altenkamp Norbert Maria &lt;NA&gt; männlich 45 27.07… &lt;NA&gt; Union ## 17 17 Altmaier Peter &lt;NA&gt; männlich 51 18.06… &lt;NA&gt; Union ## 18 18 Altmaier Peter &lt;NA&gt; männlich 55 18.06… &lt;NA&gt; Union ## 19 19 Altmaier Peter &lt;NA&gt; männlich 59 18.06… &lt;NA&gt; Union ## 20 19 Amthor Philipp &lt;NA&gt; männlich 24 10.11… &lt;NA&gt; Union ## # … with 2,040 more rows 3.2 Datentransformation mit dplyr Das dplyr package enthält eine Reihe von Funktionen zur Bereinigung, Transformation und deskriptiven Analyse von Daten. Wir beginnen damit, Zeilen und Spalten, die wir nicht benötigen, aus der Tibble zu entfernen, bevor wir die Daten in einigen bestehenden Spalten transformieren und neue Spalten aus den vorhandenen Daten erzeugen. Empfohlene weiterführende Resourcen zu dplyr sind das entsprechende RStudio Cheatsheet: https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-transformation.pdf sowie das Kapitel “Data transformation” in “R for Data Science”: https://r4ds.had.co.nz/transform.html 3.2.1 filter() filter() dient dazu, Beobachtungen – also Zeilen – aus einer Tibble zu filtern. Die Funktion nimmt dabei die Daten, auf die sie angewandt werden soll, als erstes und eine oder mehrere expressions als zweites Argument. Diese Ausdrücke sind letztlich die Regeln, nach denen die Funktion filtern soll. Zum Schreiben der Ausdrücke benötigen wir die in Kapitel 1.2.4 bereits eingeführten Vergleichsoperatoren. Diese vergleichen den Wert auf der linken Seite des Operators mit dem auf der rechten und geben als Ergebnis ein TRUE zurück, wenn der Test bestanden wurde, beziehungsweise FALSE, wenn er nicht bestanden wurde. Wir könnten nun beispielsweise daran interessiert sein, nur die Daten bestimmter Fraktionen zu analysieren. Filtern wir zunächst die Stammdaten der Unions-Abgeordneten heraus. Wir können dazu in filter() testen, ob der Wert der Spalte “fraktion” gleich dem Wert “Union” ist. Bitte denken Sie daran, dass wir zum Vergleich zweier Werte immer == schreiben müssen, nicht =. stammdaten_17_19 %&gt;% filter(fraktion == &quot;Union&quot;) ## # A tibble: 830 × 9 ## wp nachname vorname praefix geschlecht alter geb Titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Abercron Michael von männlich 64 17.11… Dr. Union ## 2 17 Aigner Ilse &lt;NA&gt; weiblich 44 07.12… &lt;NA&gt; Union ## 3 18 Albani Stephan &lt;NA&gt; männlich 45 03.06… &lt;NA&gt; Union ## 4 19 Albani Stephan &lt;NA&gt; männlich 49 03.06… &lt;NA&gt; Union ## 5 18 Albsteiger Katrin &lt;NA&gt; weiblich 29 20.11… &lt;NA&gt; Union ## 6 19 Altenkamp Norbert Maria &lt;NA&gt; männlich 45 27.07… &lt;NA&gt; Union ## 7 17 Altmaier Peter &lt;NA&gt; männlich 51 18.06… &lt;NA&gt; Union ## 8 18 Altmaier Peter &lt;NA&gt; männlich 55 18.06… &lt;NA&gt; Union ## 9 19 Altmaier Peter &lt;NA&gt; männlich 59 18.06… &lt;NA&gt; Union ## 10 19 Amthor Philipp &lt;NA&gt; männlich 24 10.11… &lt;NA&gt; Union ## # … with 820 more rows Möchten wir mehrere Ausdrücke kombinieren, benötigen wir dazu logische Operatoren. &amp; – UND – testet, ob beide verbundenen Ausdrücke gleichzeitig TRUE sind und gibt nur dann TRUE zurück. | – ODER – testet, ob wenigstens einer der verbundenen Ausdrücke TRUE ist und gibt in diesem Fall TRUE zurück. Dies sind alle möglichen Kombinationen für 2 Ausdrücke: TRUE &amp; TRUE gibt TRUE zurück TRUE &amp; FALSE, FALSE &amp; TRUE und FALSE &amp; FALSE geben alle FALSE zurück TRUE | TRUE, TRUE | FALSE und FALSE | TRUE geben alle TRUE zurück FALSE | FALSE gibt FALSE zurück Möchten wir nun beispielsweise alle Unions-Abgeordneten des 19. Bundestags filtern, können wir dazu den &amp; Operator einsetzen: stammdaten_17_19 %&gt;% filter(fraktion == &quot;Union&quot; &amp; wp == 19) ## # A tibble: 261 × 9 ## wp nachname vorname praefix geschlecht alter geb Titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Abercron Michael von männlich 64 17.1… Dr. Union ## 2 19 Albani Stephan &lt;NA&gt; männlich 49 03.0… &lt;NA&gt; Union ## 3 19 Altenkamp Norbert Maria &lt;NA&gt; männlich 45 27.0… &lt;NA&gt; Union ## 4 19 Altmaier Peter &lt;NA&gt; männlich 59 18.0… &lt;NA&gt; Union ## 5 19 Amthor Philipp &lt;NA&gt; männlich 24 10.1… &lt;NA&gt; Union ## 6 19 Auernhammer Artur &lt;NA&gt; männlich 54 09.0… &lt;NA&gt; Union ## 7 19 Aumer Peter &lt;NA&gt; männlich 41 17.0… &lt;NA&gt; Union ## 8 19 Bär Dorothee &lt;NA&gt; weiblich 39 19.0… &lt;NA&gt; Union ## 9 19 Bareiß Thomas &lt;NA&gt; männlich 42 15.0… &lt;NA&gt; Union ## 10 19 Barthle Norbert &lt;NA&gt; männlich 65 01.0… &lt;NA&gt; Union ## # … with 251 more rows Möchten wir die MdBs der großen Koalition aus dem Datensatz filtern, also Abgeordnete der Union oder der SPD, können wir dies mit | realisieren: stammdaten_17_19 %&gt;% filter(fraktion == &quot;Union&quot; | fraktion == &quot;SPD&quot;) ## # A tibble: 1,353 × 9 ## wp nachname vorname praefix geschlecht alter geb Titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Abercron Michael von männlich 64 17.11… Dr. Union ## 2 17 Aigner Ilse &lt;NA&gt; weiblich 44 07.12… &lt;NA&gt; Union ## 3 18 Albani Stephan &lt;NA&gt; männlich 45 03.06… &lt;NA&gt; Union ## 4 19 Albani Stephan &lt;NA&gt; männlich 49 03.06… &lt;NA&gt; Union ## 5 18 Albsteiger Katrin &lt;NA&gt; weiblich 29 20.11… &lt;NA&gt; Union ## 6 19 Altenkamp Norbert Maria &lt;NA&gt; männlich 45 27.07… &lt;NA&gt; Union ## 7 17 Altmaier Peter &lt;NA&gt; männlich 51 18.06… &lt;NA&gt; Union ## 8 18 Altmaier Peter &lt;NA&gt; männlich 55 18.06… &lt;NA&gt; Union ## 9 19 Altmaier Peter &lt;NA&gt; männlich 59 18.06… &lt;NA&gt; Union ## 10 19 Amthor Philipp &lt;NA&gt; männlich 24 10.11… &lt;NA&gt; Union ## # … with 1,343 more rows Es lassen sich auch mehr als zwei Ausdrücke mit &amp; bzw. | kombinieren. Beispielsweise um die die Abgeordneten der Oppositionsfraktionen zu filtern: stammdaten_17_19 %&gt;% filter(fraktion == &quot;AfD&quot; | fraktion == &quot;FDP&quot; | fraktion == &quot;Die Grünen&quot; | fraktion == &quot;DIE LINKE.&quot;) ## # A tibble: 705 × 9 ## wp nachname vorname praefix geschlecht alter geb Titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Achelwilm Doris &lt;NA&gt; weiblich 40 30.11.1976 &lt;NA&gt; DIE LINK… ## 2 17 Ackermann Jens &lt;NA&gt; männlich 34 02.07.1975 &lt;NA&gt; FDP ## 3 19 Aggelidis Grigorios &lt;NA&gt; männlich 52 19.08.1965 &lt;NA&gt; FDP ## 4 17 Ahrendt Christian &lt;NA&gt; männlich 46 07.05.1963 &lt;NA&gt; FDP ## 5 19 Akbulut Gökay &lt;NA&gt; weiblich 34 16.11.1982 &lt;NA&gt; DIE LINK… ## 6 17 Aken Jan van männlich 48 01.05.1961 &lt;NA&gt; DIE LINK… ## 7 18 Aken Jan van männlich 52 01.05.1961 &lt;NA&gt; DIE LINK… ## 8 17 Alpers Agnes &lt;NA&gt; weiblich 48 29.06.1961 &lt;NA&gt; DIE LINK… ## 9 18 Alpers Agnes &lt;NA&gt; weiblich 52 29.06.1961 &lt;NA&gt; DIE LINK… ## 10 19 Alt Renata &lt;NA&gt; weiblich 52 27.08.1965 &lt;NA&gt; FDP ## # … with 695 more rows Die Daten enthalten aktuell noch alle Abgeordneten der 17. - 19. Legislaturperioden. Im rahmen dieser Einführung, arbeiten wir nur mit den MdBs des 19. Bundestags. Mit filter() können wir den Datensatz auf diese reduzieren. stammdaten_19 &lt;- stammdaten_17_19 %&gt;% filter(wp == 19) Ab hier arbeiten wir mit dem Objekt stammdaten_19 weiter. 3.2.2 select() Möchten wir ein Subset von Variablen bilden, könne wir dazu select() nutzen. Die Funktion nimmt die Daten, auf die sie angewendet werden soll, als erstes Argument – hier weitergegeben durch die Pipe – und dann einen oder mehrere Spaltennamen, die in der Tibble verbleiben sollen. Folgen die zu behaltenden Spalten aufeinander, können wir auch eine “von:bis” Notation nutzen. Nehmen wir an, wir möchten die Spalten “nachname”, “vorname”, “praefix” und “fraktion” extrahieren: stammdaten_19 %&gt;% select(nachname, vorname, praefix, fraktion) ## # A tibble: 750 × 4 ## nachname vorname praefix fraktion ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Abercron Michael von Union ## 2 Achelwilm Doris &lt;NA&gt; DIE LINKE. ## 3 Aggelidis Grigorios &lt;NA&gt; FDP ## 4 Akbulut Gökay &lt;NA&gt; DIE LINKE. ## 5 Albani Stephan &lt;NA&gt; Union ## 6 Alt Renata &lt;NA&gt; FDP ## 7 Altenkamp Norbert Maria &lt;NA&gt; Union ## 8 Altmaier Peter &lt;NA&gt; Union ## 9 Amthor Philipp &lt;NA&gt; Union ## 10 Amtsberg Luise &lt;NA&gt; Die Grünen ## # … with 740 more rows stammdaten_19 %&gt;% select(nachname:praefix, fraktion) ## # A tibble: 750 × 4 ## nachname vorname praefix fraktion ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Abercron Michael von Union ## 2 Achelwilm Doris &lt;NA&gt; DIE LINKE. ## 3 Aggelidis Grigorios &lt;NA&gt; FDP ## 4 Akbulut Gökay &lt;NA&gt; DIE LINKE. ## 5 Albani Stephan &lt;NA&gt; Union ## 6 Alt Renata &lt;NA&gt; FDP ## 7 Altenkamp Norbert Maria &lt;NA&gt; Union ## 8 Altmaier Peter &lt;NA&gt; Union ## 9 Amthor Philipp &lt;NA&gt; Union ## 10 Amtsberg Luise &lt;NA&gt; Die Grünen ## # … with 740 more rows Wir können select()auch nutzen, um Variablen zu entfernen. Dazu schreiben wir - vor den zu entfernenden Spaltennamen. Da das genaue Geburtsdatum der Abgeordneten im Folgenden nicht mehr benötigt wird, können wir die Spalte “geb” entfernen. stammdaten_19 &lt;- stammdaten_19 %&gt;% select(-geb) stammdaten_19 ## # A tibble: 750 × 8 ## wp nachname vorname praefix geschlecht alter Titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Abercron Michael von männlich 64 Dr. Union ## 2 19 Achelwilm Doris &lt;NA&gt; weiblich 40 &lt;NA&gt; DIE LINKE. ## 3 19 Aggelidis Grigorios &lt;NA&gt; männlich 52 &lt;NA&gt; FDP ## 4 19 Akbulut Gökay &lt;NA&gt; weiblich 34 &lt;NA&gt; DIE LINKE. ## 5 19 Albani Stephan &lt;NA&gt; männlich 49 &lt;NA&gt; Union ## 6 19 Alt Renata &lt;NA&gt; weiblich 52 &lt;NA&gt; FDP ## 7 19 Altenkamp Norbert Maria &lt;NA&gt; männlich 45 &lt;NA&gt; Union ## 8 19 Altmaier Peter &lt;NA&gt; männlich 59 &lt;NA&gt; Union ## 9 19 Amthor Philipp &lt;NA&gt; männlich 24 &lt;NA&gt; Union ## 10 19 Amtsberg Luise &lt;NA&gt; weiblich 33 &lt;NA&gt; Die Grünen ## # … with 740 more rows 3.2.3 rename() Ihnen wird eventuell bereits aufgefallen sein, dass alle Spaltennamen außer “Titel” mit einem kleingeschriebenen Buchstaben beginnen. Da habe ich anscheinend beim Erstellen des Datenobjekts meine eigenen Namenskonventionen – alles beginnt mit kleinen Buchstaben – außer Acht gelassen. Um diese nun umzubenennen, können wir rename() nutzen. Erneut werden als erstes Argument die Daten durch die Pipe weitergegeben, gefolgt von einem oder mehreren Argumenten in der Form neuer_name = alter_name. stammdaten_19 &lt;- stammdaten_19 %&gt;% rename(titel = Titel) stammdaten_19 ## # A tibble: 750 × 8 ## wp nachname vorname praefix geschlecht alter titel fraktion ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 19 Abercron Michael von männlich 64 Dr. Union ## 2 19 Achelwilm Doris &lt;NA&gt; weiblich 40 &lt;NA&gt; DIE LINKE. ## 3 19 Aggelidis Grigorios &lt;NA&gt; männlich 52 &lt;NA&gt; FDP ## 4 19 Akbulut Gökay &lt;NA&gt; weiblich 34 &lt;NA&gt; DIE LINKE. ## 5 19 Albani Stephan &lt;NA&gt; männlich 49 &lt;NA&gt; Union ## 6 19 Alt Renata &lt;NA&gt; weiblich 52 &lt;NA&gt; FDP ## 7 19 Altenkamp Norbert Maria &lt;NA&gt; männlich 45 &lt;NA&gt; Union ## 8 19 Altmaier Peter &lt;NA&gt; männlich 59 &lt;NA&gt; Union ## 9 19 Amthor Philipp &lt;NA&gt; männlich 24 &lt;NA&gt; Union ## 10 19 Amtsberg Luise &lt;NA&gt; weiblich 33 &lt;NA&gt; Die Grünen ## # … with 740 more rows 3.2.4 mutate() mutate() dient dazu, Daten in bestehenden Spalten zu transformieren und neue Spalten aus den Daten bestehender Spalten zu generieren. Dabei schreiben wir innerhalb der Klammern den Namen der zu transformierenden oder neu zu erstellenden Spalte = einem Ausdruck der beschreibt, wir die Daten transformiert oder generiert werden sollen. Dies kann eine einfache Berechnung wie mutate(neue_spalte = spalte_a + spalte b) sein, aber auch weitere Funktionen beinhalten. Auch in mutate() können wir innerhalb der Klammern mehrere mutate-Schritte der Form alte/neue_Spalte = Ausdruck durch Kommata “aneinanderhängen”. Hier erstellen wir eine kleine Tibble mit Beispieldaten um die Funktionsweise von mutate() zu veranschaulichen: exmpl_tbl &lt;- tibble(x1 = 1:5, x2 = 5:1) exmpl_tbl ## # A tibble: 5 × 2 ## x1 x2 ## &lt;int&gt; &lt;int&gt; ## 1 1 5 ## 2 2 4 ## 3 3 3 ## 4 4 2 ## 5 5 1 exmpl_tbl %&gt;% mutate(x1 = sqrt(x1), x3 = x1 * x2, x4 = round(x3, digits = 2)) ## # A tibble: 5 × 4 ## x1 x2 x3 x4 ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 5 5 5 ## 2 1.41 4 5.66 5.66 ## 3 1.73 3 5.20 5.2 ## 4 2 2 4 4 ## 5 2.24 1 2.24 2.24 In diesem Beispiel wird der Inhalt der Spalte “x1” durch die Quadratwurzel der enthaltenen Werte ersetzt – sqrt() ist eine base R Funktion zum Ziehen der Quadratwurzel. Die Originalwerte werden also mit den transformierten Werten ersetzt. Die Werte in “x2” werden hier nicht ersetzt. Die Spalten “x3” und “x4” werden beide neu aus den Werten der bestehenden Spalten erstellt. Bitte beachten Sie dabei, dass bei der Erstellung von “x3” bereits die transformierten Werte aus “x1” in die Berechnung eingehen, nicht die Originalwerte. Die Funktion round(), welche bei der Erstellung von “x4” genutzt wird, rundet die Werte aus “x3” auf zwei Nachkommastellen. Die Anzahl Nachkommastellen wird über das optionale Argument digits = kontrolliert. Geben wir dies nicht an, wird auf Null Nachkommastellen, also Ganzzahlen, gerundet. Gehen wir nun zur Transformation unseres Datensatzes über. Die Spalte “titel” listet aktuell die akademischen Titel der Abgeordneten. Liegt ein Titel vor, wird dieser genau benannt. Liegt keiner vor enthält die Spalte ein NA, die Repräsentation fehlender Werte in R. Für diese Analyse interessiert uns nur, ob ein Titel vorliegt, aber nicht welcher. Dazu könnten wir eine neue Spalte generieren, welche einen logischen Vektor enthält, der angibt, ob ein Titel vorliegt (TRUE) oder nicht (FALSE). Dies ist eine sogenannte Dummyvariable. Zum Generieren können wir die dplyr Funktion if_else() nutzen. Wir geben als erstes Argument eine Bedingung an, die getestet wird. Hier !is.na(titel), welche testet ob der Inhalt von “titel” nicht – angezeigt durch das ! – missing ist. Das zweite und dritte Argument geben an, was eingesetzt werden soll wenn die getestete Bedingung erfüllt beziehungsweise nicht erfüllt ist. Hier soll im ersten Fall TRUE, im zweiten FALSE eingesetzt werden. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(titel_dummy = if_else(!is.na(titel), TRUE, FALSE)) stammdaten_19 %&gt;% select(titel, titel_dummy) ## # A tibble: 750 × 2 ## titel titel_dummy ## &lt;chr&gt; &lt;lgl&gt; ## 1 Dr. TRUE ## 2 &lt;NA&gt; FALSE ## 3 &lt;NA&gt; FALSE ## 4 &lt;NA&gt; FALSE ## 5 &lt;NA&gt; FALSE ## 6 &lt;NA&gt; FALSE ## 7 &lt;NA&gt; FALSE ## 8 &lt;NA&gt; FALSE ## 9 &lt;NA&gt; FALSE ## 10 &lt;NA&gt; FALSE ## # … with 740 more rows Die Spalte “fraktion” ist aktuell als Character Vektor abgelegt. Bei der Fraktionszugehörigkeit handelt es sich aber um eine kategoriale Variable. So gibt es nur eine begrenzte Anzahl möglicher Ausprägungen, nämlich die Namen der im 19. Bundestag vertretenen Fraktionen sowie die Kategorie “Flos” für Fraktionslose. Die Repräsentation kategorialer Variablen in R nennt sich factor. Das core tidyverse Package forcats ermöglicht es uns, Faktorvariablen anzulegen und zu manipulieren. Der einfachste Weg ist es, R selbst auslesen zu lassen, welche Kategorien in einer Variable vorhanden sind. Dazu wenden wir einfach die Funktion factor() innerhalb von mutate() auf eine Spalte an. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(fraktion = factor(fraktion)) Um herauszufinden, welche Kategorien ein factor vector umfasst, nutzen wir levels(). levels(stammdaten_19$fraktion) ## [1] &quot;AfD&quot; &quot;Die Grünen&quot; &quot;DIE LINKE.&quot; &quot;FDP&quot; &quot;Flos&quot; ## [6] &quot;SPD&quot; &quot;Union&quot; Dies scheint funktioniert zu haben. R hat automatisch und korrekt alle Ausprägungen der Varibale erkannt und jede einem factor zugeordnet. Aktuell sind die Kategorien alphabetisch geordnet, inhaltlicher sinnvoller wäre aber beispielsweise eine Ordnung nach der Größe der Fraktionen im 19. Bundestag. Um die Kategorien manuell neu zu ordnen, könnten wir fct_relevel() nutzen. Dazu müssten wir aber die gewünschte Reihenfolge per Hand notieren. Bequemer geht es mit fct_infreq(), welche die Kategorien automatisch nach der Häufigkeit Ihres Auftretens in den Daten ordnet. Also in unserem Fall von der Kategorie mit den meisten Abgeordneten bis zu der mit den wenigsten. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(fraktion = fct_infreq(fraktion)) levels(stammdaten_19$fraktion) ## [1] &quot;Union&quot; &quot;SPD&quot; &quot;AfD&quot; &quot;FDP&quot; &quot;Die Grünen&quot; ## [6] &quot;DIE LINKE.&quot; &quot;Flos&quot; Dass die Grünen vor der Linken eingeordnet wurden obwohl die Linken im 19. Bundestag zwei Mandate mehr hatten, liegt daran, dass der Datensatz auch ausgeschiedene MdBs umfasst. Von diesen hatten die Grünen drei mehr, so dass sie sich in der Gesamtzahl von Beobachtungen im Datensatz knapp vor die Linke setzen. Die Spalte “geschlecht” liegt ebenfalls als Character Vektor vor und kann auf dem selben Weg in einen Factor umgewandelt werden. stammdaten_19 &lt;- stammdaten_19 %&gt;% mutate(geschlecht = factor(geschlecht)) levels(stammdaten_19$geschlecht) ## [1] &quot;männlich&quot; &quot;weiblich&quot; Damit sind die Daten zur weiteren Analyse vorbereitet. Die Spalte “titel” ist allerdings nicht mehr notwendig, da wir die enthaltenen Informationen in die neue Dummyvariable überführt haben. Wir können diese also mit select() entfernen. stammdaten_19 &lt;- stammdaten_19 %&gt;% select(-titel) stammdaten_19 ## # A tibble: 750 × 8 ## wp nachname vorname praefix geschlecht alter fraktion titel_dummy ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;lgl&gt; ## 1 19 Abercron Michael von männlich 64 Union TRUE ## 2 19 Achelwilm Doris &lt;NA&gt; weiblich 40 DIE LINKE. FALSE ## 3 19 Aggelidis Grigorios &lt;NA&gt; männlich 52 FDP FALSE ## 4 19 Akbulut Gökay &lt;NA&gt; weiblich 34 DIE LINKE. FALSE ## 5 19 Albani Stephan &lt;NA&gt; männlich 49 Union FALSE ## 6 19 Alt Renata &lt;NA&gt; weiblich 52 FDP FALSE ## 7 19 Altenkamp Norbert Maria &lt;NA&gt; männlich 45 Union FALSE ## 8 19 Altmaier Peter &lt;NA&gt; männlich 59 Union FALSE ## 9 19 Amthor Philipp &lt;NA&gt; männlich 24 Union FALSE ## 10 19 Amtsberg Luise &lt;NA&gt; weiblich 33 Die Grünen FALSE ## # … with 740 more rows 3.3 Speichern der transformierten Daten Wir werden im nächsten Kapitel mit den hier transformierten Daten weiterarbeiten. Dazu sollten Sie entweder zu Beginn des Kapitels das Script aus diesem Kapitel nochmals durchlaufen lassen, oder Sie speichern die bearbeiteten Daten: save(stammdaten_19, file = &quot;stammdaten_19.RData&quot;) 3.4 Deskriptive Datenanalyse mit dplyr 3.4.1 summarise() Die Funktion summarise() ermöglicht es uns, zusammenfassende Maßzahlen zu einer Tibble zu berechnen. Die Syntax funktioniert dabei ähnlich zu mutate(). Wir definieren einen Namen für die Spalte, in der die Maßzahlen gelistet werden sollen, und nach dem = eine entsprechende Berechnung oder Funktion. Das Ergebnis ist ein neue Tibble, welche die angeforderten Statistiken enthält. Betrachten wir zunächst die Spalte “alter”. Wir könnten uns für das arithmetische Mittel des Alters der MdBs interessieren. Dazu definieren wir innerhalb von summarise() den Namen der neuen Spalte und nach dem = nutzen wir die base R Funktion mean(): stammdaten_19 %&gt;% summarise(arith_mittel = mean(alter)) ## # A tibble: 1 × 1 ## arith_mittel ## &lt;dbl&gt; ## 1 49.4 Wir können uns auch mehrere Statistiken gleichzeitig ausgeben, indem wir die entsprechenden Anfragen mit , verbinden: stammdaten_19 %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), median = median(alter), maximum = max(alter)) ## # A tibble: 1 × 4 ## minimum arith_mittel median maximum ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 24 49.4 50 77 Das sieht alles schon ordentlich aus, ist aber auch auf einfacherem Wege erzielbar, beispielsweise mit der praktischen base R Funktion summary(). Wirklich mächtig wird summarise() erst durch die Kombination mit group_by(). So können wir die Daten gruppieren und die zusammenfassenden Statistiken für jede dieser Gruppen separat berechnen. 3.4.2 summarise() &amp; group_by() Unsere Daten bieten sich für eine Analyse nach Fraktionszugehörigkeit an. Als ersten Schritt können wir die Daten also nach dem Inhalt der Spalte “fraktion” gruppieren und zunächst einmal zählen, wie viele Abgeordnete pro Fraktion im Bundestag vertreten sind. Hier bitte erneut beachten, dass sowohl ausgeschiedene Abgeordnete sowie deren NachrückerInnen im Datensatz enthalten sind. Die Analyseergebnisse werden dementsprechend nicht exakt mit der Mandatszahl übereinstimmen. Innerhalb von summarise() nutzen wir hier die dplyr Funktion n(), welche die Anzahl Beobachtungen pro Gruppe, also die Gruppengröße, zurückgibt. stammdaten_19 %&gt;% group_by(fraktion) %&gt;% summarise(abgeordnete = n()) ## # A tibble: 7 × 2 ## fraktion abgeordnete ## &lt;fct&gt; &lt;int&gt; ## 1 Union 261 ## 2 SPD 165 ## 3 AfD 94 ## 4 FDP 85 ## 5 Die Grünen 72 ## 6 DIE LINKE. 71 ## 7 Flos 2 Eben haben wir das Durchschnittsalter aller Abgeordneten berechnet. Dies können wir natürlich auch gruppiert nach Fraktionen machen. stammdaten_19 %&gt;% group_by(fraktion) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) ## # A tibble: 7 × 7 ## fraktion minimum arith_mittel std_abweichung median maximum anzahl ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Union 24 50.0 9.72 51 75 261 ## 2 SPD 27 50.3 9.35 52 68 165 ## 3 AfD 26 50.9 12.2 50 77 94 ## 4 FDP 24 45.6 10.7 46 76 85 ## 5 Die Grünen 26 46.9 9.90 47.5 64 72 ## 6 DIE LINKE. 27 50.4 9.72 52 69 71 ## 7 Flos 42 42 0 42 42 2 Oft ist es hilfreich, die Daten nach einer Statistik, die uns interessiert, zu ordnen. Möchten wir beispielsweise wissen, welche Fraktion den höchsten beziehungsweise niedrigsten Mittelwert des Alters hat, können wir die Ergebnisse in einem weiteren Schritt mit der Funktion arrange() nach den Werten dieser Variable ordnen. Die zusätzliche Funktion desc() bewirkt, dass die Daten absteigend geordnet werden. stammdaten_19 %&gt;% group_by(fraktion) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) %&gt;% arrange(desc(arith_mittel)) ## # A tibble: 7 × 7 ## fraktion minimum arith_mittel std_abweichung median maximum anzahl ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 AfD 26 50.9 12.2 50 77 94 ## 2 DIE LINKE. 27 50.4 9.72 52 69 71 ## 3 SPD 27 50.3 9.35 52 68 165 ## 4 Union 24 50.0 9.72 51 75 261 ## 5 Die Grünen 26 46.9 9.90 47.5 64 72 ## 6 FDP 24 45.6 10.7 46 76 85 ## 7 Flos 42 42 0 42 42 2 Für die Mehrzahl der Fraktionen liegt der Mittelwert des Alters bei ca. 50 Jahren. Dabei beträgt die Differenz des arithmetischen Mitels zwischen AfD und Union etwa 1 Jahr. Wir sehen für die AfD aber auch eine höhere Standardabweichung und einen niedrigeren Median. Wir könnten also vermuten, dass in der AfD einige besonders alte Abgeordnete vertreten sind, welche den Mittelwert nach oben verzerren. Die FDP ist dem Mittelwert nach die jüngste, die Grünen die zweitjüngste Fraktion. Während sich das Alter der jüngsten Fraktionsmitglieder relativ wenig unterscheidet, bestehen beim Alter der ältesten Mitglieder deutliche Unterschiede. Während es bei den Grünen keine MdBs über 64 gibt, geht das Maximalalter bei AfD, Union und FDP bis in die mittleren 70er. Die Statistiken für die Gruppe der fraktionslosen sind nicht besonders belastbar, da sie nur aus zwei Personen besteht, und lassen sich nicht sinnvoll analysieren. Diesen ersten Befunden werden wir bei der graphischen Analyse im folgenden Kapitel weiter auf den Grund gehen. Die Spalte “titel_dummy” ist ein logischer Vektor der TRUE enthält, wenn ein MdB einen akademischen Titel besitzt und FALSE, wenn keiner vorliegt. Hinter einem logischen Vektor stehen Zahlenwerte. TRUE ist die Repräsentation von 1, FALSE von 0. Wir können also direkt mit den Werten des Vektors rechnen. Um die absolute Anzahl an Titeln zu berechenn, reicht es so die Summe des Vektors zu bilden. Alle Werte werden aufaddiert und da wir nur Einsen und Nullen haben, ist das Ergebnis gleich der Anzahl der Abgeordneten, die einen akademischen Titel tragen. Um den relativen Anteil zu berechnen, können wir das arithmetische Mittel nutzen. Alle Einsen und Nullen werden aufaddiert und durch die Anzahl der Beobachtungen geteilt. Dies ist der Anteil der Abgeordneten mit Titel. stammdaten_19 %&gt;% summarise(absolut = sum(titel_dummy), relativ = mean(titel_dummy) ) ## # A tibble: 1 × 2 ## absolut relativ ## &lt;int&gt; &lt;dbl&gt; ## 1 147 0.196 Wir könnten uns dafür interessieren, ob sich das Alter der Abgeordneten mit Titel von denen unterscheidet die keinen Titel tragen. Dazu gruppieren wir nach der Spalte “titel_dummy” und berechnen die Statistiken zum Alter. stammdaten_19 %&gt;% group_by(titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) ## # A tibble: 2 × 7 ## titel_dummy minimum arith_mittel std_abweichung median maximum anzahl ## &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 FALSE 24 49.1 10.1 50 77 603 ## 2 TRUE 28 50.8 10.6 50 76 147 Abgeordnete mit Titel sind im Durchschnitt etwas älter. Dies macht Sinn, da sowohl das Erlangen eines Titels als auch eines Bundestagmandats hohe Zeitinvestitionen darstellen. Wir können auch nach mehreren Spalten gleichzeitig gruppieren. In diesem Fall werden die Statistiken für jede Gruppenkombination berechnet. stammdaten_19 %&gt;% group_by(fraktion, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) ## `summarise()` has grouped output by &#39;fraktion&#39;. You can override using the `.groups` argument. ## # A tibble: 14 × 8 ## # Groups: fraktion [7] ## fraktion titel_dummy minimum arith_mittel std_abweichung median maximum ## &lt;fct&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Union FALSE 24 49.7 9.83 51 70 ## 2 Union TRUE 32 50.9 9.32 50 75 ## 3 SPD FALSE 27 50.2 9.45 52 68 ## 4 SPD TRUE 33 50.9 8.95 49.5 67 ## 5 AfD FALSE 26 49.8 11.7 49 77 ## 6 AfD TRUE 28 54.8 13.5 55.5 76 ## 7 FDP FALSE 24 44.9 9.77 46 66 ## 8 FDP TRUE 31 48.4 13.5 44.5 76 ## 9 Die Grünen FALSE 26 47.8 10.1 49 64 ## 10 Die Grünen TRUE 34 43.8 8.79 42.5 64 ## 11 DIE LINKE. FALSE 27 49.0 9.74 50 66 ## 12 DIE LINKE. TRUE 48 56.9 6.67 56 69 ## 13 Flos FALSE 42 42 NA 42 42 ## 14 Flos TRUE 42 42 NA 42 42 ## # … with 1 more variable: anzahl &lt;int&gt; Wir sehen an den Mittelwerten, dass der oben für den gesamten Bundestag analysierte Unterschied im mittleren Alter von MdBs mit und ohne Titel nicht für alle Fraktionen gleichermaßen gilt. Während Titelträger in AfD, FDP und LINKE im Mittel klar älter sind als Abgeordnete ohne Titel, ist die Differenz für die Union und die SPD relativ gering. Bei den Grünen sind Titelträger im Mittel sogar deutlich jünger. Auch dies werden wir in der graphischen Analyse erneut betrachten. An dieser Stelle müssen wir noch über eine Besonderheit in der Zusammenarbeit von group_by() und summarise() sprechen, welche zu Problemen führen kann, wenn Sie sich ihr nicht bewusst sind. Grundsätzlich wird jeder Aufruf von summarise() nach einem group_by() Befehl eine Ebene der Gruppierung auflösen. Für die Beispiele in denen wir nur nach Fraktion oder Titel gruppiert haben, bedeutet dies also, dass die Daten nach dem summarise() Befehl nicht mehr gruppiert waren. Wir hatten eine Gruppierungsebene und diese wurde automatisch entfernt. Im letzten Beispiel hatten wir zwei Gruppierungsebenen. Von diesen wurde nur die niedrigere Gruppierungsebene – die Reihenfolge der Variablen in group_by() bestimmt auch die Reihenfolge der Gruppierung –, also die Gruppierung nach dem Titel aufgelöst. Die Gruppierung nach der Fraktionsmitgliedschaft ist weiterhin aktiv. Dies ist auch im Output anhand der Zeile # Groups: fraktion [7] erkennbar. Die Daten sind nach der Fraktion gruppiert und wir haben 7 Gruppen. Möchten wir mit den Ergebnissen dieser Berechnungen weiterarbeiten, müssen wir uns auch über die Gruppierung bewusst sein. Sollen die Daten weiterhin gruppiert sein? Dann ist alles gut, sollen sie es nicht sein müssen wir die Gruppierung vollständig auflösen. Dies machen wir mit der Funktion ungroup(). Solange Sie sich nicht sicher sind, dass Sie die Gruppierung wirklich weiterhin brauchen, würde ich immer zu einem ungroup() am Ende einer group_by() und summarise() Operation mit mehreren Gruppen tendieren. So verhindern sie versehentliche Berechnungen auf Gruppenbasis und die Gruppierung lässt sich jederzeit schnell wieder herstellen, sollte dies notwendig werden. stammdaten_19 %&gt;% group_by(fraktion, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) %&gt;% ungroup() ## `summarise()` has grouped output by &#39;fraktion&#39;. You can override using the `.groups` argument. ## # A tibble: 14 × 8 ## fraktion titel_dummy minimum arith_mittel std_abweichung median maximum ## &lt;fct&gt; &lt;lgl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Union FALSE 24 49.7 9.83 51 70 ## 2 Union TRUE 32 50.9 9.32 50 75 ## 3 SPD FALSE 27 50.2 9.45 52 68 ## 4 SPD TRUE 33 50.9 8.95 49.5 67 ## 5 AfD FALSE 26 49.8 11.7 49 77 ## 6 AfD TRUE 28 54.8 13.5 55.5 76 ## 7 FDP FALSE 24 44.9 9.77 46 66 ## 8 FDP TRUE 31 48.4 13.5 44.5 76 ## 9 Die Grünen FALSE 26 47.8 10.1 49 64 ## 10 Die Grünen TRUE 34 43.8 8.79 42.5 64 ## 11 DIE LINKE. FALSE 27 49.0 9.74 50 66 ## 12 DIE LINKE. TRUE 48 56.9 6.67 56 69 ## 13 Flos FALSE 42 42 NA 42 42 ## 14 Flos TRUE 42 42 NA 42 42 ## # … with 1 more variable: anzahl &lt;int&gt; 3.5 Export von Tabellen Ein flexibler Weg zum direkten Export von Tabellen ist es, diese als “.csv” abzuspeichern. Dieses Format kann wiederum direkt in Excel importiert werden. CSV steht für “comma-separated values”. Da diese Dateien sehr einfach gehalten sind und von einer großen Bandbreite an Software verarbeitet werden können, ist CSV eines der meistgenutzten Formate für zweidimensionale Datenstrukturen. Hier fehlt der Platz um ins Detail zu gehen, aber wir können kurz die Grundstruktur einer CSV Datei betrachten: column1, column2, column3 data1_1, data1_2, data1_3 data2_1, data2_2, data2_3 data3_1, data3_2, data3_3 Die Zeilen einer Tabelle sind durch Zeilenumbrüche getrennt, die Spalten durch Kommata. In der ersten Zeile stehen dabei häufig, aber nicht immer, die Spaltennamen. Damit wissen Sie bereits das Wichtigste. Mehr zu “.csv” Dateien finden sie unter: https://jakobtures.github.io/web-scraping/files.html Wir können beispielsweise das Ergebnis einer summarise() Operation mit write_csv() aus readr (core tidyverse) abspeichern. stammdaten_19 %&gt;% group_by(fraktion, titel_dummy) %&gt;% summarise(minimum = min(alter), arith_mittel = mean(alter), std_abweichung = sd(alter), median = median(alter), maximum = max(alter), anzahl = n()) %&gt;% ungroup() %&gt;% write_csv(file = &quot;alter_fraktion_titel_1.csv&quot;) ## `summarise()` has grouped output by &#39;fraktion&#39;. You can override using the `.groups` argument. Aus Gründen, die vermutlich nur Microsoft selbst bekannt sind – ich tippe auf missverstandene “Nutzerfreundlichkeit” –, können “.csv” Dateien, in denen die Spalten durch Kommata getrennt sind – der internationale Standard –, auf deutschen Windows Systemen oft nicht ohne weiteres importiert werden. Nutzen Sie statt Microsoft Office die Open Source Alternative LibreOffice, ist das Problem bereits behoben. Möchten Sie aber Microsoft Office auf einem deutschen System nutzen, sollten Sie die Datei eventuel im Deutschen Standard speichern. Dabei werden statt Kommata Semikolons als Trennzeichen der Spalten verwendet, da die Kommata in Deutschland zur Darstellung von Dezimalzahlen benötigt werden. Dies ist mit write_csv2() auf einfachem Wege möglich. 3.5.0.1 Weiterführende Resourcen Es existiert eine Vielzahl von Packages, die Funktionen zur Formatierung und dem Export von Tabellen mitbringen. Aus Platzgründen können wir nicht auf die Details eingehen, hier aber einige Startpunkte: Möchten sie direkt nach “.xlsx” exportieren, wären zwei der Optionen: writexl: https://cran.r-project.org/web/packages/writexl/index.html openxlsx: https://cran.r-project.org/web/packages/openxlsx/index.html Tabellen direkt im “.docx” Format zu erstellen ermöglicht flextable: https://davidgohel.github.io/flextable/ huxtable kann Tabellen im “.tex” Format zur Arbeit in LaTeX ausgeben, beherrscht aber auch HTML sowie Word, Excel und Powerpoint Output: https://hughjonesd.github.io/huxtable/ Möchten sie externe Software zum Schreiben von Hausarbeiten und Papers ganz umgehen, könnte R Markdown für Sie von Interesse sein. Dies ermöglicht das gleichzeitige Schreiben von Text und Code in einem Dokument. Die Ausgabe lässt sich in unterschiedliche Formate exportieren und kann neben dem Text auch Code, der dargestellt werden soll, sowie Tabellen und Grafiken enthalten. Einige Resourcen zu R Markdown finden Sie hier: Einführung der RStudio website: https://rmarkdown.rstudio.com/lesson-1.html{target_“blank”} Das R Markdown cheatsheet: https://raw.githubusercontent.com/rstudio/cheatsheets/master/rmarkdown.pdf Kapitel zu R Markdown in “R for Data Science” von Hadley Wickham und Garrett Grolemund: https://r4ds.had.co.nz/r-markdown.html “R Markdown Cookbook” von Yihui Xie, Christophe Dervieux, Emily Riederer: https://bookdown.org/yihui/rmarkdown-cookbook/ Die Website, die Sie aktuell betrachten, sowie viele der verlinkten Resourcen sind mit bookdown geschrieben, welches auf R Markdown aufbaut und sich vor allem für umfangreichere Projekte eignet. “bookdown: Authoring Books and Technical Documents with R Markdown” von Yihui Xie: https://bookdown.org/yihui/bookdown/ "],["R4.html", "4 Graphische Analyse mit ggplot2 4.1 ggplot2 syntax 4.2 Graphische Analyse der Stammdaten 4.3 Graphiken exportieren", " 4 Graphische Analyse mit ggplot2 Wir arbeiten in diesem Kapitel mit den in Kapitel 3 transformierten Daten weiter. Dazu müssten Sie entweder das Script aus der Vorwoche nochmals durchführen, den unten stehenden code Block, welcher alle Veränderungen an den Daten in kompakter Form enthält ausführen, oder sie laden die Daten – vorausgesetzt Sie haben sie gespeichert. Vor dem Laden der Daten müssen wir erneut das tidyverse laden. library(tidyverse) load(&quot;stammdaten_17_19.RData&quot;) stammdaten_19 &lt;- stammdaten_17_19 %&gt;% filter(wp == 19) %&gt;% rename(titel = Titel) %&gt;% mutate(titel_dummy = if_else(!is.na(titel), TRUE, FALSE), fraktion = factor(fraktion), fraktion = fct_infreq(fraktion), geschlecht = factor(geschlecht)) %&gt;% select(-c(geb, titel)) 4.1 ggplot2 syntax Die graphische Datenanalyse mit dem core tidyverse package ggplot2 folgt einer intuitiven Logik. Jede Grafik beginnt mit dem Initieren eines leeren plots. Diese leere “Leinwand” füllen wir dann in weiteren Schritten mit den darzustellenden graphischen Elementen. Zum Initieren des plots nutzen wir die Funktion ggplot() – auch wenn der Name des packages ggplot2 lautet, trägt der Funktionsname keine “2”. Der Funktion geben wir das Datenobjekt welches geplottet werden soll als Argument. ggplot(data = stammdaten_19) Die neu erstellte Grafik öffnet sich im “Plots” Tab von RStudio und erstrahlt in blendender Leere, da wir noch keine graphischen Elemente hinzugefügt haben. 4.1.1 geoms &amp; aesthetics Diese graphischen Element werden geoms genannt. Wir fügen Sie einem plot hinzu indem wir nach ggplot() ein + schreiben und den Befehl für das geom in der nächsten Zeile eingeben. Weitere geoms können wir auf die selbe Art und Weise hinzufügen. Die grundsätzliche Syntax – dies ist kein ausführbarer Code – sieht damit wie folgt aus: ggplot(data = ...) + geom_1() + geom_2() + ... Die geom Funktionen beginnen immer mit geom_ und enden mit einem Wort das die Art des graphischen Objekts beschreibt. Beispielsweise geom_point() für scatterplots, geom_line() für lineplots oder geom_bar() für barplots. Die aesthetics eines geoms dienen zur Zuordnung der x und y Variablen die in das Koordinatensytem geplottet werden sollen. Darüber hinaus können aesthetics auch genutzt werden um die graphische Darstellung der geplottet Elemente anhand der Werte einer weiteren Variable zu manipulieren – beispielsweise die Farbe oder Größe geplotteter Punkte oder die Dicke von Linien. Dies klingt noch sehr abstrakt, wird aber in späteren Beispielen deutlich werden. Betrachten wir zunächst, wie die Zuordnung von x und y Variablen syntaktisch funktioniert. Diese müssen festgelegt werden. Alle weiteren aesthetics sind optional. Zur Definition der aesthetics nutzen wir die Funktion aes() als ein Argument der jeweiligen geom Funktion. Innerhalb von aes() weisen wir x und y die Variablen die auf der x-Achse beziehungsweise der y-Achse abgetragen werden sollen zu. Die Syntax sieht wie folgt aus: ggplot(data = ...) + geom_1(aes(x = x_variable, y = y_variable)) + geom_2(aes(x = x_variable, y = y_variable)) + ... Nutzen wir die selben x und y Variablen für alle geoms, können wir die Zuordnung auch direkt in der Funktion ggplot() vornehmen. ggplot(data = ..., aes(x = x_variable, y = y_variable)) + geom_1() + geom_2() + ... Dies ist die grundsätzliche Syntax von ggplot2. Im Folgenden nutzen wir das package zur graphischen Analyse unserer Beispieldaten. Dabei betrachten wir nur einen Teil der verfügbaren geoms und der Möglichkeiten die Darstellung über die aesthetics und weitere Optionen zu manipluieren. Als Übersicht über alle verfügbaren geoms empfehle ich dringend das cheatsheet für ggplot2: https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-visualization.pdf Eine ausführlichere Einführung gibt das Kapitel “Data visualisation” in “R for Data Science”: https://r4ds.had.co.nz/data-visualisation.html 4.2 Graphische Analyse der Stammdaten Variablen sind kontinuierlich, wenn sie jeden Wert – möglicherweise im Minimum und Maximum begrenzt – annehmen können. Sie sind auch immer numerisch. Ein in den Sozialwissenschaften häufig anzutreffendes Beispiel für eine kontinuierliche Variable wäre das Einkommen beziehungsweise monetäre Werte im Allgemeinen, vorausgesetzt sie werden als exakter Geldwert gemessen. In unserem Beispielsdatensatz ist das Alter der MdBs eine kontinuierliche Variable. Variablen sind kategorial, wenn Sie als Werte nur eine begrenzte Anzahl vordefinierter Kategorien annehmen können. Wird das Einkommen statt als exakter Wert als Mitgliedschaft in breiten Einkommensgruppen gemessen, ist dies eine kategoriale Variable. In den Beispieldaten sind die Fraktionsmitgliedschaft, das Geschlecht sowie die Dummyvariable zum akademischen Titel kategoriale Variablen. Geoms können danach unterschieden werden, für welche Typen von x und y Variablen sie anwendbar sind. Dieser Logik folgt auch das oben verlinkte cheatsheet. 4.2.1 kontinuierliches x &amp; y Das Alter ist die einzige kontinuierliche Variable in unserem Beispielsdatensatz. Damit eignet sich der Beispieldatensatz nicht zum Plotten zweier kontinuierlicher Variablen. Stattdessen, generieren wir im folgenden Zufallssaten für Mietpreise und Quadratmeter fiktiver Wohnungen in einer Stadt. Bevor wir nun Zufallswerte generieren, müssen wir uns über eines bewusst sein: Zufallswerte sind Zufallswerte. Bei jeder wiederholten Ziehung der Zufallswerte, werden wir andere Werte erhalten. Meist sind wir aber daran interessiert, auch zufällig gezogene Werte reproduzieren zu können. Also bei jeder wiederholten Ziehung, beispielsweise wenn wir am nächsten Tag an einem Projekt weiterarbeiten, dieselben Zufallswerte zu erhalten. Dies können wir ermöglichen, in dem wir vor dem Ziehen der Zahlen einen sogenannten Seed setzen. Dieser Seed legt den Startpunkt des Random Number Generators (RNG) fest. Dieser Startpunkt bestimmt, welche Zahlen in welcher Reihenfolge zufällig generiert werden und sicher die Reproduzierbarkeit unserer Arbeit. Die Funktion set.seed(), mit einer beliebigen Zahl zwischen den Klammern – hier das Datum der Seminarsitzung – setzt den Seed. Der folgende Codeblock generiert unsere Zufallsdaten als eine Tibble. Die Spalte “size” enthält 1000 Zufallswerte aus einer Normalverteilung mit einem Mittelwert von 70 und einer Standardabweichung von 15. Dies sind die Quadratmeterzahlen unser fiktiver Wohnungen. Für die Spalte “premium” werden 1000 Werte aus der Binomialverteilung gezogen. Mit einer Wahrscheinlichkeit von 20% ist der Wert TRUE, mit 80% FALSE. Die Variable soll einige Wohnungen zufällig als besonders teuer kennzeichnen – möglicherweise aufgrund ihrer exklusiven Lage. Auf Basis der Werte von “size” und “premium”, berechnet sich der Mitpreis in “price” wie folgt: Ausgehend von einer fiktiven Quadratmetermiete von 10€, wird zunächst etwas “Rauschen” hinzugefügt (Addition/Subtraktion von Werten aus einer Normalverteilung mit einem Mittelwert von 0 und einer Standardabweichung von 3). Handelt es sich um eine “Premiumwohnung”, werden auf diesen Preis nochmals 10€ aufgeschlagen. Nun wird der Quadratmeterpreis mit der Größe der Wohnung multipliziert um den finalen Mietpreis zu berechnen. set.seed(170522) rent &lt;- tibble( size = rnorm(1000, mean = 70, sd = 15), premium = as.logical(rbinom(n = 1000, size = 1, prob = 0.2)), price = size * (10 + rnorm(1000, mean = 0, sd = 3) + (10 * premium)) ) rent %&gt;% head(n = 5) ## # A tibble: 5 × 3 ## size premium price ## &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 77.2 TRUE 1473. ## 2 66.1 FALSE 574. ## 3 56.4 FALSE 801. ## 4 90.7 TRUE 2290. ## 5 59.8 TRUE 1197. Nun können wir unsere Zufallsdaten plotten. Typischerweise wird die erklärende unabhängige Variable, hier size, auf der x-Achse und die zu erklärende abhängige Variable, price, auf der y-Achse abgetragen. Mit geom_point() können wir einen scatterplot erstellen um die Kombinationen der Werte für x- und y-Variablen als Punkte in einem Koordinatensystem darzustellen. ggplot(data = rent, aes(x = size, y = price)) + geom_point() Da wir die Daten selbst generiert haben, wissen wir bereits, dass x- und y-Variable positiv miteinander korreliert sind. Auch ohne dieses Wissen, würde uns ein erster Blick auf die Punktewolke vermutlich einen positiven linearen Zusammenhang vermuten lassen. Um diese Vermutung zu überprüfen, könnten wir eine lineare Regressionsgerade in den Plot legen. Diese visualisiert den Zusammenhang zwischen zwei Variablen und wird so über die Daten gelegt, dass Sie deren Zusammenhang bestmöglichst beschreibt, also die Abweichung von den tatsächlichen Daten minimiert. Eine Regressionsgerade erhalten wir, indem wir dem Plot das geom_smooth() hinzufügen und dabei das Argument method = \"lm\" setzen. “lm” steht dabei für “linear model”, also eine lineare Regression. Das weitere Argument se = FALSE sorgt dafür, dass kein Konfidenzinterval – ein Maß für die Unsicherheit des geschätzten Zusammenhangs – um die Gerade angezeigt wird. ggplot(data = rent, aes(x = size, y = price)) + geom_point() + geom_smooth(method = &#39;lm&#39;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; Der Winkel in dem die Regressionsgerade verläuft – die slope – zeigt uns den Zusammenhang zwischen beiden Variablen an, welcher hier klar positiv ist. Wir haben die Zufallsdaten so konstruiert, dass es eine Klasse von Wohnungen gibt, welche besonders teuer sind. Die Korrelation zwischen Größe und Preis unterscheidet sich also zwischen diesen Gruppen. Dies können wir in unserem Plot visualisieren in dem wir die Variable premium nutzen um die Daten zu gruppieren und sowohl Punkte als auch Regressionsgeraden getrennt nach dem Wert der dritten Variable abzutragen. Zur Gruppierung legen wir eine weitere aesthetic fest. Dazu könnten wir das Argument group = premium setzen. Um Punkte und Geraden auch farblich abzugrenzen, bietet sich aber colour = premium an. ggplot(data = rent, aes(x = size, y = price, colour = premium)) + geom_point() + geom_smooth(method = &#39;lm&#39;, se = FALSE) ## `geom_smooth()` using formula &#39;y ~ x&#39; Wir sehen klar, dass sich die Slope beider Geraden unterscheidet. Die Korrelation zwischen Größe und Preis ist für Premiumwohnungen stärker. Sidenote: In diesem Fall haben wir die Daten selbst konstruiert und waren uns über die Zusammenhänge der Variablen im Vorfeld bewusst. Die Zusammenhänge in echten Daten kennen wir nicht, wir können aber basiert auf theoretischen Überlegungen Annahmen zu Zusammenhängen treffen und diese, unter anderem, mit vergleichbaren graphischen Analysen überprüfen. 4.2.2 kategoriales x, kontinuierliches y In Kapitel 3 haben wir mit summarise() und group_by() die Anzahl von Beobachtungen pro Fraktion berechnet. Diese könnten wir auch in einer Graphik darstellen. Die Variable zur Fraktionsmitgliedschaft ist dabei eine kategoriale Variable, die Anzahl der Abgeordneten ist kontinuierlich, liegt aber nicht als Variable vor. Dies benötigen wir aber auch nicht, da geom_bar() – für barplots – die Anzahl von Beobachtungen pro Kategorie der x Variable automatisch berechnet. So müssen wir in den aesthetics auch nur die x Variable zuordnen. stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar() So schnell und einfach kommen wir zu einem barplot der Fraktionsmitgliedschaft. Die Darstellung ist dabei aber nicht sonderlich hübsch. Ein erster Schritt wäre es, die Achsen sowie die Graphik selbst sinnvoll zu beschriften. die Funktion labs() erlaubt die Benennung der zentralen Graphikbestandteile, beispielsweise: stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar() + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) Soweit, so gut. Aber die Balken sind doch noch sehr eintönig grau. In der aes() Funktion innerhalb von geom_bar() oder auch ggplot(), können wir über das fill = Argument festlegen, dass die Balken nach dem Wert einer Variable eingefärbt werden sollen. Setzen wir dieses gleich der Variable “fraktion”, bekommt jeder Balken eine eigene Farbe zugewiesen. Die automatisch erstellte Farblegende, verstecken wir mit einem weiteren Argument. stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar(aes(fill = fraktion), show.legend = FALSE) + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) Noch schöner wäre es, wenn die Balkenfarben mit den tatsächlichen Parteifarben übereinstimmen würden. Dazu können wir die Farben der Balken per Hand festlegen statt sie automatisch zuweisen zu lassen. Hier erstellen wir einen Vektor mit Farbnamen den wir dann für das fill = Argument nutzen. Beachten Sie dabei, dass fill = diesmal nicht innerhalb von aes() steht. Dies liegt daran, dass wir die Farben nicht anhand einer Variable festlegen sondern konstant zuweisen, was außerhalb von aes() erfolgt. parteifarben &lt;- c(&quot;black&quot;, &quot;red&quot;, &quot;deepskyblue&quot;, &quot;yellow2&quot;, &quot;limegreen&quot;, &quot;violetred&quot;, &quot;grey&quot;) stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar(fill = parteifarben) + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) Eine Übersicht über alle verfügbaren Farben, finden Sie unter: http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf Mich persönlich stört an dieser Stelle noch der graue Hintergrund des plots. Dieser ist Teil des standard themes von ggplot2, theme_gray(). Wir können aber auch andere themes auswählen. Eine Übersicht finden sie hier: https://ggplot2.tidyverse.org/reference/ggtheme.html stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar(fill = parteifarben) + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Nutzen wir für die fill aesthetic eine zweite Variable, beispielsweise die Informationen zu akademischen Titeln, erhalten wir einen gestapelten barplot. Hier macht es wiederum Sinn, die automatisch erstellte Farblegende nicht auszublenden. stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar(aes(fill = titel_dummy)) + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate mit/ohne Titel im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Möchten wir die Balken nicht stapeln sondern nebeneinander darstellen, können wir dies über das Argument position = \"dodge\" festlegen. Um die Darstellung weiter aufzuhübschen können wir außerdem den Titel der Farblegende in labs() anpassen. stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar(aes(fill = titel_dummy), position = &quot;dodge&quot;) + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate mit/ohne Titel im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;, fill = &quot;Akadem. Titel&quot;) + theme_minimal() 4.2.3 kontinuierliches x In Kapitel 3 haben wir deskriptive Statistiken zur Altersverteilung berechnet. Auch diese können wir graphisch darstellen. Dazu bietet sich unter anderem geom_histogram() an. Ein Histogramm unterteilt eine kontinuierliche Variable in eine festlegbare Anzahl von Abschnitten – bins – und stellt die Anzahl von Beobachtungen die in jedes bin fallen als Balken dar. Als Standard unterteilt ggplot2 eine Variable in 30 bins, dies können wir aber über das bins = Argument beeinflussen. stammdaten_19 %&gt;% ggplot(aes(x = alter)) + geom_histogram() + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Um die Grafik besser interpretierbar zu machen, könnten wir eine vertikale Linie hinzufügen die den Mittelwert der x Variable markiert. Dazu nutzen wir geom_vline() und legen für xintercept = den x Wert fest, an dem die Linie eingezeichnet werden soll. Außerdem scheint es angebracht, die Anzahl der bins zu reduzieren. Mit 30 bins, deckt jeder Balken knapp 2 Jahre ab. So werden zufällige Fluktuationen in der Altersverteilung überbetont. stammdaten_19 %&gt;% ggplot(aes(x = alter)) + geom_histogram(bins = 15) + geom_vline(aes(xintercept = mean(alter)), colour = &quot;red&quot;) + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Wir sehen, dass die Alterstruktur annäherend um den Mittelwert normalverteilt ist, die Verteilung aber leicht links-schief ist. Das bedeutet, dass die Verteilung auf der linken Seite etwas langsamer ansteigt als die auf der rechten abnimmt. Dies ist hier vor allem mit dem starken Abfall von Mandatsträgern beim Erreichen des Rentenalters erklärbar. Durch das Verringern der bins auf 15 – jeder bin deckt so 3-4 Jahre ab –, erscheint die Altersverteilung deutlich näher an einer Normalverteilung, da Fluktuationen in der Altersverteilung so weniger betont werden. Wenn es unser Ziel ist, die generelle Altersverteilung im Bundestag zu bewerten, macht dieser Ansatz aus meiner Sicht auch durchaus Sinn. Wir sollten aber davon absehen, solange an der “bins-Schraube” zu drehen, bis wir ein Bild bekommen, dass uns gefällt. Vielmehr sollten wir vor dem plotten darüber nachdenken, was das Ziel der graphischen Darstellung ist und die bins entsprechend festlegen. Möchten wir die Histogramme für alle Fraktionen vergleichen, können wir facets nutzen. Dabei werden in einem plot mehrere einzelne plots neben- und untereinander dargestellt. In der Funktion facet_wrap() schreiben wir dazu den Namen der Variable nachdem die Kacheln gebildet werden sollen und setzen davor eine Tilde ~. stammdaten_19 %&gt;% ggplot(aes(x = alter)) + geom_histogram(bins = 15) + facet_wrap(~ fraktion) + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag nach Fraktion&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Um dies besser interpretierbar zu machen, könnten wir die Mittelwerte des Alters für jede Fraktion einzeichnen. Diese müssen wir dazu zunächst pro Fraktion berechen. Dazu nutzen wir wiederum die dplyr Funktionen und hängen ggplot() am Ende der Pipe an. In diesem Zuge, können wir auch die Fraktionslosen herausfiltern, da ihre Anzahl für eine inhaltliche Interpretation deutlich zu klein ist. stammdaten_19 %&gt;% filter(fraktion != &quot;Flos&quot;) %&gt;% group_by(fraktion) %&gt;% mutate(arith_mittel = mean(alter)) %&gt;% ungroup() %&gt;% ggplot(aes(x = alter)) + geom_histogram(bins = 15) + geom_vline(aes(xintercept = arith_mittel), colour = &quot;red&quot;) + facet_wrap(~ fraktion) + labs(x = &quot;Alter&quot;, y = &quot;Anzahl&quot;, title = &quot;Altersverteilung im 19. Bundestag nach Fraktion&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() Die Befunde aus Kapitel 3 lassen sich zunächst bestätigen. Der relativ hohe Mittelwert der AfD wird durch viele besonders alte Mandatsträger:innen etwas nach oben verschoben. Keine andere Fraktion hat so “viele” – es geht hier eigentlich um eine geringe Anzahl von Personen – Abgeordnete über 70. FDP und Grüne als die im Mittelwert jüngsten Fraktionen unterscheiden sich in Ihrer Altersspannweite. Die FDP hat viele sehr junge aber auch sehr alte MdBs, während die Spannweite bei den Grünen deutlich enger ist. Wir erkennen nun auch, dass die Altersverteilung in der Union relativ nahe an der generellen Altersverteilung des 19. Bundestags liegt. Interessant sind die Verteilungen von SPD und von DIE LINKE. Anders als die alleinige Betrachtung des Mittelwerts suggeriert, liegt der Schwerpunkt der Altersverteilung in beiden Fraktionen bei den über 50-jährigen. Es gilt zu erinnern, dass die Histogramme für die kleineren Fraktionen auf wenig Fällen basieren. Die Fluktuationen zwischen den bins sollten deshalb nicht überinterpretiert werden. Eine Alternative zu Histogrammen sind density plots. Diese können wir als geglätte Version eines Histogramms verstehen. Statt abgesteckter bins, für welche jeweils die Anzahl Beobachtungen die in dieses Interval der x Variable fallen exakt gezählt werden, wird bei einem density plot die “Dichte” der Daten über alle x Werte hinweg geschätzt. Diese Dichte wird auf der y-Achse abgetragen und summiert sich zu 1 auf. Dabei werden Fluktuationen in der Verteilung weniger detailliert abgebildet, aber wie bekommen dafür ein klareres Bild der generellen Verteilung einer kontinuierlichen Variable. Zwei weitere Vorteile sind, dass wir für density plots keine Entscheidungen zur Größe beziehungsweise Anzahl der bins treffen müssen und diese sich besser zum übereinanderlegen eignen als Histogramme. So könnten wir beispielsweise die in Kapitel 3 bereits angesprochene Altersverteilung für Träger akademischer Titel und Personen ohne einen Titel in zwei übereinandergelegten density plots gleichzeitig betrachten und vergleichen. Dazu plotten wir mit geom_density() und nutzen entweder die fill oder colour aesthetic. Bei fill wird die Fläche unter der Kurve gefüllt, bei colour werden nur die Kurven farblich gezeichnet. stammdaten_19 %&gt;% ggplot(aes(x = alter, colour = titel_dummy)) + geom_density() + labs(x = &quot;Alter&quot;, y = &quot;Density&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;, colour = &quot;Akadem. Titel&quot;) + theme_minimal() Beide Verteilungen sind sich relativ ähnlich, bei den Titelträgern gibt es aber einen höheren Anteil besonders alter MdBs. Wir haben auch bereits gesehen, dass es möglicherweise Unterschiede zwischen den Fraktionen gibt. Diese können wir erneut mit einem facet vergleichen. Dazu filtern wir zunächst die Fraktionslosen heraus, da durch ihre geringe Anzahl nicht genug Daten zur Verfügung stehen um belastbare Ergebnisse zur Verteilung zu berechnen. stammdaten_19 %&gt;% filter(fraktion != &quot;Flos&quot;) %&gt;% ggplot(aes(x = alter, colour = titel_dummy)) + geom_density() + facet_wrap(~ fraktion) + labs(x = &quot;Alter&quot;, y = &quot;Density&quot;, title = &quot;Altersverteilung im 19. Bundestag&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;, colour = &quot;Akadem. Titel&quot;) + theme_minimal() Die plots bestätigen die Ergebnisse aus Kapitel 3 weitestgehend. Union und SPD Mandatsträger mit und ohne Titel sind in der Altersverteilung sehr ähnlich. In AfD und LINKE sind Träger akademischer Titel klar älter. Bei den GRÜNEN klar jünger. Bei der FDP ist das Bild etwas differenzierter. Während Mandatsträger ohne Titel vornehmlich jüngeren bis mittleren Alters sind, ist die Alterverteilung bei Titelträgern relativ gleich über alle Alter hinweg. 4.3 Graphiken exportieren Nachdem wir nun einige schöne Graphiken erstellt haben, folgt die Frage, wie wie diese in unsere Papers und Hausarbeiten einbinden können. Arbeiten wir in R Markdown, können wir direkt den ggplot2 Output nutzen, arbeiten wir aber in externer Software – z. B. Word oder LaTeX – müssen wir die Graphiken exportieren. Ein einfacher Weg ist die Funktion ggsave(). Um die letzte erstelle Graphik abzuspeichern, müssen wir ggsave() nur einen Dateinamen beziehungsweise Pfad als Argument mitgeben. Das Format der Graphik legen wir dabei einfach über die Dateiendung fest. Ich empfehle generell eine Vektorgraphik zu nutzen – beispielsweise “.eps” oder “.svg”. Der Vorteil ist, dass diese stufenlos skalierbar sind. Wir können die Größe der Graphik beim Import also in beide Richtungen anpassen, ohne dass die Darstellungsqualität leidet. Pixelbasierte Formate wie “.jpeg” oder “.png” sind bereits komprimiert und verlieren dadruch an Qualität. Möchten wir diese vergrößern, wird die Darstellung zunehmend verschwommen. Das Verkleinern funktioniert eventuell besser, kann aber auch graphische Artefakte erzeugen. Hier speichern wir die letzte erstellte Graphik – die density plots nach Fraktionen – als “.eps”. ggsave(&quot;age_density_by_party.eps&quot;) ## Saving 7 x 5 in image Flexibler einsetzen lässt sich sich ggsave() wenn wir plots zunächst einem Objekt zuweisen. So ist es nicht mehr notwendig direkt nach der Erstellung einer Graphik den Export vorzunehmen. Hier erstellen wir zwei Graphiken und weisen diese zunächst Objekten zu, um sie später abzuspeichern. Durch die Objektzuweisung bekommen wir dabei keinen Output. Ich würde empfehlen zunächst die Graphik zu gestalten bis das Endergebnis erreicht ist und die Objektzuweisung erst dann hinzuzufügen. Die erstellten Graphiken exportieren wir am Ende des Blocks. Dabei handelt es sich um den barplot der Abgeordneten nach Fraktionen. Einmal wie oben als Version mit den Parteifarben, einmal als greyscale Variante, welche sich besser zum Druck eignet. Dazu fügen wir scale_fill_grey() hinzu. mdb_partei_colour &lt;- stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar(fill = parteifarben) + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + theme_minimal() mdb_partei_grey &lt;- stammdaten_19 %&gt;% ggplot(aes(x = fraktion)) + geom_bar(aes(fill = fraktion)) + labs(x = &quot;Fraktion&quot;, y = &quot;Mandate&quot;, title = &quot;Anzahl Mandate im 19. Bundestag nach Fraktionszugehörigkeit&quot;, caption = &quot;Daten: https://www.bundestag.de/services/opendata&quot;) + scale_fill_grey() ggsave(&quot;mdb_party_colour.eps&quot;, plot = mdb_partei_colour) ## Saving 7 x 5 in image ggsave(&quot;mdb_party_grey.eps&quot;, plot = mdb_partei_grey) ## Saving 7 x 5 in image Wir können für ggsave() noch weitere Argumente festlegen. Zum Beispiel um die Größe und Auflösung der Graphik einzustellen. Diese sind vor allem interessant, wenn wir uns für das Speichern in einem pixelbasierten Format entscheiden. Für mehr Informationen betrachten Sie bitte ?ggsave(). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
